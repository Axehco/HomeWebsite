<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>有多少小于当前数字的数字</title>
      <link href="2021/01/01/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2021/01/01/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="有多少小于当前数字的数字" href="https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">有多少小于当前数字的数字</p><p class="url">https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/</p></div></a></div><p>给你一个数组 <code>nums</code>，对于其中每个元素 <code>nums[i]</code>，请你统计数组中比它小的所有数字的数目。</p><p>换而言之，对于每个 <code>nums[i]</code> 你必须计算出有效的<code> j</code> 的数量，其中 <code>j</code> 满足<code> j != i</code> 且<code> nums[j] &lt; nums[i]</code> 。</p><p>以数组形式返回答案。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [8,1,2,2,3]</span><br><span class="line">输出：[4,0,1,1,3]</span><br><span class="line">解释： </span><br><span class="line">对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 </span><br><span class="line">对于 nums[1]&#x3D;1 不存在比它小的数字。</span><br><span class="line">对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 </span><br><span class="line">对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [6,5,4,8]</span><br><span class="line">输出：[2,1,0,3]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [7,7,7,7]</span><br><span class="line">输出：[0,0,0,0]</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;&#x3D; nums.length &lt;&#x3D; 500</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt;&#x3D; 100</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力实现"><a href="#暴力实现" class="headerlink" title="暴力实现"></a>暴力实现</h3><p>最简单粗暴的方式：采用暴力实现，二重循环遍历数组即可，即两层for循环暴力查找，时间复杂度明显为$O(n^2)$。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> index1, value1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> index2, value2 <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">                <span class="keyword">if</span> index1 != index2 <span class="keyword">and</span> value1 &gt; value2:</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            ans.append(count)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>但是采用这种方式，因为涉及二重循环，其时间复杂度太高，不建议采取。</p><h3 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h3><p>这种方法只需要遍历一遍待排数组即可，具体思路如下：</p><p>提前建立一个从0-100的空数组用来计数，在待排数组里遇到一个数就在计数数组里对应位置+1。</p><p>题目要求比此数小的，也就是刚才的计数数组里，当前位置（表示对应的nums里的一个数n），之前的数（比n小的数字的个数）的总和。<del>理解不了没关系，看一遍代码就懂了。</del></p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">101</span>  <span class="comment"># 计数数组：题目强调0 &lt;= nums[i] &lt;= 100，则最多101个空间即可</span></span><br><span class="line">        out = []  <span class="comment"># 记录最终答案</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> nums:</span><br><span class="line">            count[n] += <span class="number">1</span>  <span class="comment"># 计数器，第n个数加1</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span>  <span class="comment"># 存放count数组的累加值</span></span><br><span class="line">        ans = []  <span class="comment"># 将比它小的数列举出进行存放</span></span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> count:</span><br><span class="line">            ans.append(<span class="built_in">sum</span>)</span><br><span class="line">            <span class="built_in">sum</span> += value</span><br><span class="line">        <span class="keyword">for</span> value <span class="keyword">in</span> nums:</span><br><span class="line">            out.append(ans[value])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>计数排序可能是所有排序里最快的一种，因为它不涉及比较。</li><li>缺点：需要的空间很大。所以一般只涉及数字且范围较小的时候，还能应付，一旦涉及到字母混数字排序就无能为力了。</li></ul><h3 id="排序哈希"><a href="#排序哈希" class="headerlink" title="排序哈希"></a>排序哈希</h3><p>首先要找小于当前数字的数字，那么从小到大排序之后，该数字之前的数字就都是比它小的了。</p><p>所以可以定义一个新数组，将数组排个序。</p><p>排序之后，其实每一个数值的下标就代表这前面有几个比它小的了。</p><p>此时有一个情况，就是<strong>数值相同怎么办？</strong></p><p>可以这样处理：将数组降序排列，此时要得到<code>小于当前数字的数字</code>，它与降序排列的下标有什么关系呢？</p><p>$$要找的小于当前数字的数字=len(nums)-1-数组下标$$</p><p>此时再用一个哈希表hash来做数值和下标的映射，这样就可以通过数值快速知道下标。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">smallerNumbersThanCurrent</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        out = []</span><br><span class="line">        temp = <span class="built_in">sorted</span>(nums, reverse=<span class="literal">True</span>)  <span class="comment"># 降序排列</span></span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">101</span>  <span class="comment"># 根据题意，哈希表最多101个空间即可</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(temp):</span><br><span class="line">            <span class="built_in">hash</span>[j] = <span class="built_in">len</span>(nums) - <span class="number">1</span> - i  <span class="comment"># 此写法为了避免nums中有相同的数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            out.append(<span class="built_in">hash</span>[i])</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数组 </tag>
            
            <tag> 计数排序 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索插入位置</title>
      <link href="2020/11/28/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/"/>
      <url>2020/11/28/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="搜索插入位置" href="https://leetcode-cn.com/problems/search-insert-position/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">搜索插入位置</p><p class="url">https://leetcode-cn.com/problems/search-insert-position/</p></div></a></div><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>你可以假设数组中无重复元素。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,3,5,6], 0</span><br><span class="line">输出: 0</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>要在数组中插入目标值，只有一下四种情况：</p><ul><li>目标值在数组所有元素之前</li><li>目标值等于数组中某一个元素</li><li>目标值插入数组中的位置</li><li>目标值在数组所有元素之后</li></ul><h3 id="暴力实现"><a href="#暴力实现" class="headerlink" title="暴力实现"></a>暴力实现</h3><p>直接遍历数组即可</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target &lt;= num:</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(nums)</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n)$<br>空间复杂度：$O(1)$</p><h3 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h3><p>首先要注意：<strong>二分的条件是数组有序，本题满足条件</strong></p><p>同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。</p><p>既然暴力解法的时间复杂度是$O(n)$，就要尝试一下使用二分查找法。</p><p>二分查找涉及的很多的边界条件，逻辑比较简单，但是稍不注意，就会弄错。</p><ul><li><code>while(left &lt; right)</code>与<code>while(left &lt;= right)</code>采用哪种写法？</li><li><code>right = middle</code>与<code>right = middle - 1</code>又采用哪种写法?</li></ul><p>这里弄不清楚主要是因为<strong>对区间的定义没有想清楚，这就是不变量</strong>。</p><p>要在二分查找的过程中，保持不变量，这也就是<code>循环不变量</code></p><blockquote><p>第一种写法：定义 target 是在一个在左闭右闭的区间里，即**[left, right]**</p></blockquote><p>​    <strong><em>AC代码</em></strong></p><p><code>注意为什么要写while(left &lt;= right)和right = middle - 1</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums) - <span class="number">1</span>  <span class="comment"># 定义target在左闭右闭的区间里，[left, right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right):  <span class="comment"># 当left==right，区间[left, right]依然有效</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># 为了防止left + right溢出,和(left + right)/2效果一样</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[mid]:</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                right = mid - <span class="number">1</span>  <span class="comment"># target 在左区间，所以[left, middle - 1]</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># target 在右区间，所以[middle + 1, right]</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;分别处理如下四种情况</span></span><br><span class="line"><span class="string">        目标值在数组所有元素之前  [0, -1]</span></span><br><span class="line"><span class="string">        目标值等于数组中某一个元素  return mid;</span></span><br><span class="line"><span class="string">        目标值插入数组中的位置 [left, right] 此时 return  right + 1</span></span><br><span class="line"><span class="string">        目标值在数组所有元素之后的情况 [left, right] 此时 return right + 1</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>时间复杂度：$O(logn)$<br>空间复杂度：$O(1)$</p><blockquote><p>第二种写法</p></blockquote><p><strong><em>AC代码</em></strong></p><p><code>注意为什么要写while(left &lt; right)和right = middle</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchInsert</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        left = <span class="number">0</span></span><br><span class="line">        right = <span class="built_in">len</span>(nums)  <span class="comment"># 定义target在左闭右开的区间里，[left, right)</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right):  <span class="comment"># 因为left == right的时候，在[left, right)是无效的空间</span></span><br><span class="line">            mid = left + (right - left) // <span class="number">2</span>  <span class="comment"># 为了防止left + right溢出,和(left + right)/2效果一样</span></span><br><span class="line">            <span class="keyword">if</span> target == nums[mid]:</span><br><span class="line">                <span class="keyword">return</span> mid  <span class="comment"># 数组中找到目标值的情况，直接返回下标</span></span><br><span class="line">            <span class="keyword">elif</span> target &lt; nums[mid]:</span><br><span class="line">                right = mid  <span class="comment"># 在左区间，在[left, middle)中</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                left = mid + <span class="number">1</span>  <span class="comment"># 在右区间，在 [middle+1, right)中</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;分别处理如下四种情况</span></span><br><span class="line"><span class="string">        目标值在数组所有元素之前 [0,0)</span></span><br><span class="line"><span class="string">        目标值等于数组中某一个元素  return mid;</span></span><br><span class="line"><span class="string">        目标值插入数组中的位置 [left, right) 此时 return  right</span></span><br><span class="line"><span class="string">        目标值在数组所有元素之后的情况 [left, right) 此时 return  right</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(logn)$<br>空间复杂度：$O(1)$</p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247484289&idx=1&sn=929fee0ac9f308a863a4fc4e2e44506e&chksm=f9a230d0ced5b9c649391307bc40f60b501dccd9d5bb17458d363d2d8b23ebcf7f63f59ed0ca&mpshare=1&scene=1&srcid=10300gIAiwXBTxvBYxMDSwhr&sharer_sharetime=1604026217800&sharer_shareid=720193edfa0fe270e1122b3720a45d04&key=aabb5ee173354e5d41c676943ab94639478326fc847db4f199169b00f71d90b4d16554d00f0e9af5583609cd1a712e070ebb154a8fa1e4e44559fae9917a29a16c82e9cc6293b82cb809a6ea0b0f55f2d06cf9838213e1397ecf32f10fbdfd44af5fe7fcc2e0572ec54ac21328298a2ed3a34d848a23655cf30d4635ad1ae445&ascene=1&uin=MTI1MTUyODk3NQ==&devicetype=Windows+10+x64&version=6300002f&lang=zh_CN&exportkey=A9lioCnu5A1huIwyfo6DOgo=&pass_ticket=nxsJ79aEW7wiOQK9fqJRSuGiWbtWBPKTk5yAYs+QijmVhdAWiPW+ySPmBis2ntX6&wx_header=0">数组：每次遇到二分法，都是一看就会，一写就废</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数组 </tag>
            
            <tag> 暴力 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个有趣的故事理解并查集</title>
      <link href="2020/11/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>2020/11/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>一个超级有意思，好懂的并查集解释， 膜拜大神，找不到原著，所以算是知识剽窃了。</p><p><strong>并查集</strong>是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。</p><p>故事读完了，并查集就会了</p><p>江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？</p><p>我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“<del>喜羊羊同胞队</del>”，“<del>懒洋洋同胞对</del>”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。</p><p>但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。</p><p><img src="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/articles/DisjointSet01.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/articles/DisjointSet01.gif" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"></p><p>下面我们来看并查集的实现。 <code>int pre[1000]; </code>这个数组，记录了每个大侠的上级是谁。大侠们从<code>1</code>或者<code>0</code>开始编号（依据题意而定），<code>pre[15]=3</code>就表示<code>15</code>号大侠的上级是<code>3</code>号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 <code>find()</code>这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//查找我（x）的掌门</span></span><br><span class="line">    <span class="keyword">int</span> r=x;<span class="comment">//委托 r 去找掌门</span></span><br><span class="line">    <span class="keyword">while</span> (pre[r ]!=r)<span class="comment">//如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =）</span></span><br><span class="line">    r=pre[r ] ;<span class="comment">// r 就接着找他的上级，直到找到掌门为止。</span></span><br><span class="line">    <span class="keyword">return</span>  r ;<span class="comment">//掌门驾到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看<code>join()</code>函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个<code>pre[]</code>数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;<span class="comment">//我想让虚竹和周芷若做朋友</span></span><br><span class="line">    <span class="keyword">int</span> fx=find(x),fy=find(y);<span class="comment">//虚竹的老大是玄慈，芷若MM的老大是灭绝</span></span><br><span class="line">    <span class="keyword">if</span>(fx!=fy)<span class="comment">//玄慈和灭绝显然不是同一个人</span></span><br><span class="line">    pre[fx ]=fy;<span class="comment">//方丈只好委委屈屈地当了师太的手下啦</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。</p><p>设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。”</p><p>“唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。</p><p><img src="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/articles/DisjointSet02.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/articles/DisjointSet02.gif" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"></p><p>于是，问题圆满解决。。。。。。。。。</p><p>说了这么多，掌握没掌握，还得找个例题做一做呀，上才艺：</p><p>题目传送门：</p><div class="tag link"><a class="link-card" title="畅通工程" href="http://acm.hdu.edu.cn/showproblem.php?pid=1232"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">畅通工程</p><p class="url">http://acm.hdu.edu.cn/showproblem.php?pid=1232</p></div></a></div><p><strong>Problem Description</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？</span><br></pre></td></tr></table></figure><p><strong>Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。</span><br><span class="line">注意:两个城市之间可以有多条道路相通,也就是说</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 2</span><br><span class="line">2 1</span><br><span class="line">这种输入也是合法的</span><br><span class="line">当N为0时，输入结束，该用例不被处理。</span><br></pre></td></tr></table></figure><p><strong>Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对每个测试用例，在1行里输出最少还需要建设的道路数目。</span><br></pre></td></tr></table></figure><p><strong>Sample Input</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">1 3</span><br><span class="line">4 3</span><br><span class="line">3 3</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 3</span><br><span class="line">5 2</span><br><span class="line">1 2</span><br><span class="line">3 5</span><br><span class="line">999 0</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p><strong>Sample Output</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">998</span><br></pre></td></tr></table></figure><p><strong><em>AC代码</em></strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = <span class="number">1000</span> + <span class="number">5</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> pre[MAXN] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> r = x;</span><br><span class="line"><span class="keyword">while</span> (pre[r] != r)</span><br><span class="line">r = pre[r];</span><br><span class="line"><span class="keyword">int</span> i = x, j;</span><br><span class="line"><span class="keyword">while</span> (i != r) &#123;</span><br><span class="line">j = pre[i];</span><br><span class="line">pre[i] = r;</span><br><span class="line">i = j;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Join</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">x = Find(x);</span><br><span class="line">y = Find(y);</span><br><span class="line"><span class="keyword">if</span>(x != y)</span><br><span class="line">pre[x] = y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m, x, y;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">pre[i] = i;<span class="comment">//初始化节点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;<span class="comment">//合并每一条道路</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">Join(x, y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">-1</span>;<span class="comment">//注意是初始化-1，因为必然有一个的根节点是自己</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="comment">//统计未连接的道路</span></span><br><span class="line"><span class="keyword">if</span>(pre[i] == i)</span><br><span class="line">cnt++;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; cnt &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>返回倒数第k个节点</title>
      <link href="2020/11/26/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>2020/11/26/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="返回倒数第 k 个节点" href="https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">返回倒数第 k 个节点</p><p class="url">https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/</p></div></a></div><p>实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2</span><br><span class="line">输出： 4</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><p>给定的 <em>k</em> 保证是有效的。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><blockquote><p>给出一个长度未知的链表，如何找到链表中倒数第n个结点?</p></blockquote><p><strong>最容易想到的当然是：</strong>先从头到尾遍历链表，统计出链表的总长度，从而计算出倒数第n个结点相当于正数第几个结点。</p><p>比如链表总长度是<code>10</code>，倒数第<code>3</code>个结点就相当于正数第<code>8</code>个结点。然后从头遍历链表，遍历到第<code>8</code>个结点，就可得到结果。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthToLast</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        cur = head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br><span class="line">        cur = head</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, count + <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> i == count - k + <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> cur.val</span><br><span class="line">            cur = cur.<span class="built_in">next</span></span><br></pre></td></tr></table></figure><p>但是这种方法需要经过两次遍历才能得到结果，如果只用一次遍历，是否可以得到结果？</p><p><del>当然是可以的啦</del></p><p>首先，我们创建两个指针<code>p1</code>和<code>p2</code>，<code>p1</code>指向链表的头结点，<code>p2</code>指向链表的正数第<code>n</code>个结点 。</p><p>接下来,我们让指针<code>p1</code>和<code>p2</code>同时循环右移，每次右移一步，直到指针<code>p2</code>移动到链表的末尾。</p><p><img src="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.6/images/articles/LeetcodeKthNodeFromEndofListLCCI.jpg" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.6/images/articles/LeetcodeKthNodeFromEndofListLCCI.jpg" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"></p><p>此时，由于<code>p2</code>指向链表的尾结点，且<code>p1</code>和<code>p2</code>的距离是<code>n-1</code>，因此<code>p1</code>所指的结点就是我们要寻找的链表倒数第<code>n</code>个结点。</p><p>显然，这个方法从头到尾只需要对链表做一次遍历，而且仅仅使用了两个指针，算法的空间复杂度是<code>O(1)</code>。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kthToLast</span>(<span class="params">self, head: ListNode, k: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        p1 = head</span><br><span class="line">        p2 = head</span><br><span class="line">        <span class="comment"># 把p2指针移动到正数第n个结点</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(k - <span class="number">1</span>):</span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="comment"># p1和p2一起右移，直到p2指向链表尾结点</span></span><br><span class="line">        <span class="keyword">while</span> p2.<span class="built_in">next</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            p1 = p1.<span class="built_in">next</span></span><br><span class="line">            p2 = p2.<span class="built_in">next</span></span><br><span class="line">        <span class="keyword">return</span> p1.val</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 链表 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有效的字母异位词</title>
      <link href="2020/11/26/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/"/>
      <url>2020/11/26/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="有效的字母异位词" href="https://leetcode-cn.com/problems/valid-anagram/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">有效的字母异位词</p><p class="url">https://leetcode-cn.com/problems/valid-anagram/</p></div></a></div><p>给定两个字符串 <em>s</em> 和 <em>t</em> ，编写一个函数来判断 <em>t</em> 是否是 <em>s</em> 的字母异位词。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><p>你可以假设字符串只包含小写字母。</p><p><strong>进阶:</strong></p><p>如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="排序比较"><a href="#排序比较" class="headerlink" title="排序比较"></a>排序比较</h3><p>对两个字符串按照ASCII排序，比较是否相同</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> <span class="built_in">sorted</span>(s) == <span class="built_in">sorted</span>(t) <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="哈希打表"><a href="#哈希打表" class="headerlink" title="哈希打表"></a>哈希打表</h3><p>题目中字符串只有小写字符，那么就可以定义一个数组(哈希表)，来记录字符串s里字符出现的次数。</p><p>再遍历第二个字符串，把字符对应位置的计数减1</p><p>最后判断哈希表中元素是否全为0</p><p><img src="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.6/images/articles/LeetcodeValidAnagram.gif" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.6/images/articles/LeetcodeValidAnagram.gif" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"></p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span>(<span class="params">self, s: <span class="built_in">str</span>, t: <span class="built_in">str</span></span>) -&gt; bool:</span></span><br><span class="line">        hashTable = [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            hashTable[<span class="built_in">ord</span>(i) - <span class="number">97</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">            hashTable[<span class="built_in">ord</span>(i) - <span class="number">97</span>] -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> hashTable:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数反转</title>
      <link href="2020/11/26/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/"/>
      <url>2020/11/26/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="整数反转" href="https://leetcode-cn.com/problems/reverse-integer/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">整数反转</p><p class="url">https://leetcode-cn.com/problems/reverse-integer/</p></div></a></div><p>给出一个<code> 32</code> 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 123</span><br><span class="line">输出: 321</span><br></pre></td></tr></table></figure><p> <strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: -123</span><br><span class="line">输出: -321</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 120</span><br><span class="line">输出: 21</span><br></pre></td></tr></table></figure><p>注意:</p><p>假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为$[2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。</p><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h3><ul><li><p>判断整数的正负</p></li><li><p>判断反转后的整数是否溢出</p></li></ul><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reverse</span>(<span class="params">self, x: <span class="built_in">int</span></span>) -&gt; int:</span></span><br><span class="line">        flag = <span class="literal">True</span>  <span class="comment"># 标记正负数</span></span><br><span class="line">        <span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">            flag = <span class="literal">False</span></span><br><span class="line">            x = -x  <span class="comment"># 是负数，就转换为正数</span></span><br><span class="line">        x = <span class="built_in">str</span>(x)[::<span class="number">-1</span>]  <span class="comment"># 字符串反转x</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">            x = -<span class="built_in">int</span>(x)</span><br><span class="line">        x = <span class="built_in">int</span>(x)</span><br><span class="line">        <span class="keyword">return</span> x <span class="keyword">if</span> <span class="number">-1</span> * <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) &lt;= x &lt;= <span class="built_in">pow</span>(<span class="number">2</span>, <span class="number">31</span>) - <span class="number">1</span> <span class="keyword">else</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后一个单词的长度</title>
      <link href="2020/11/26/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
      <url>2020/11/26/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="最后一个单词的长度" href="https://leetcode-cn.com/problems/length-of-last-word/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">最后一个单词的长度</p><p class="url">https://leetcode-cn.com/problems/length-of-last-word/</p></div></a></div><p>给定一个仅包含大小写字母和空格<code> &#39; &#39;</code> 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。</p><p>如果不存在最后一个单词，请返回 0 。</p><p>说明：一个单词是指仅由字母组成、不包含任何空格字符的<strong>最大子字符串</strong>。</p><p><strong>示例:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;Hello World&quot;</span><br><span class="line">输出: 5</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="易错点"><a href="#易错点" class="headerlink" title="易错点"></a>易错点</h3><ul><li><p>判断字符串是否为空字符串：<code>&quot;&quot;</code>，这种情况单词长度为0</p></li><li><p>判断字符串是否全部由形如<code>&quot;   &quot;</code>的空格组成的，这种情况单词长度也为0</p></li><li><p>注意形如<code>&quot;a &quot;</code>这种情况的字符串，最后一个空格是不算在单词长度内的</p></li></ul><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>先对<code>空字符串</code>和<code>元素全是空格的字符串</code>进行判断，用一个<code>flag</code>作为标记，再将字符串按<code>&#39; &#39;</code>进行切片处理，将切片后的“单词”长度添加到一个临时列表中，反向遍历列表，第一个不为0的元素即为最后一个单词的长度。</p><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        flag = <span class="literal">True</span>  <span class="comment"># 标记是否为空字符串或元素全是空格的字符串</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">            <span class="keyword">if</span> i != <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        lst = s.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> lst:</span><br><span class="line">            ans.append(<span class="built_in">len</span>(i))  <span class="comment"># 将切片后的得到的单词长度添加到ans中</span></span><br><span class="line">        ans.reverse()  <span class="comment"># 末尾寻找“单词”</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ans:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure><h3 id="分割解法"><a href="#分割解法" class="headerlink" title="分割解法"></a>分割解法</h3><ul><li>Python <code>strip() </code>方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</li></ul><p><strong>注意：</strong>该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。</p><ul><li>Python <code>split() </code>通过指定分隔符对字符串进行切片。</li></ul><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLastWord</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; int:</span></span><br><span class="line">        s = s.strip().split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(s[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>独一无二的出现次数</title>
      <link href="2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/"/>
      <url>2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="独一无二的出现次数" href="https://leetcode-cn.com/problems/unique-number-of-occurrences/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">独一无二的出现次数</p><p class="url">https://leetcode-cn.com/problems/unique-number-of-occurrences/</p></div></a></div><p>给你一个整数数组 <code>arr</code>，请你帮忙统计数组中每个数的出现次数。</p><p>如果每个数的出现次数都是独一无二的，就返回 <code>true</code>；否则返回 <code>false</code>。</p><p> <strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,2,1,1,3]</span><br><span class="line">输出：true</span><br><span class="line">解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 1000</code></li><li><code>-1000 &lt;= arr[i] &lt;= 1000</code></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="暴力实现"><a href="#暴力实现" class="headerlink" title="暴力实现"></a>暴力实现</h3><p>建立一个范围为<code>-1000到1000</code>的数组<code>hash</code>，遍历<code>arr</code>，对<code>arr</code>的元素计数，在遍历一遍<code>hash</code>，找是否存在相同的两个不为<code>0</code>的数即可。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueOccurrences</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        <span class="built_in">hash</span> = [<span class="number">0</span>] * <span class="number">2005</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            <span class="built_in">hash</span>[i] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">hash</span>):</span><br><span class="line">            <span class="keyword">for</span> m, n <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">hash</span>):</span><br><span class="line">                <span class="keyword">if</span> m != i <span class="keyword">and</span> j == n <span class="keyword">and</span> n != <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>用此这种势必会消耗大量的<code>时间</code>和<code>空间</code>了</p><p>下面采用另外一种方式</p><h3 id="排序-集合"><a href="#排序-集合" class="headerlink" title="排序+集合"></a>排序+集合</h3><p>先排序数组，然后扫描每一个元素的出现次数并加入<code>set</code>，发现重复次数时返回<code>false</code>，遍历结束后返回<code>true</code>。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueOccurrences</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">2005</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        count.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">        set1 = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> i <span class="keyword">in</span> set1:</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    set1.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><p>你还记得<strong>集合</strong>的去重功能吗？还可以这样解：</p><p>先计算每个数出现的次数，放在<code>数组hash</code>中，再遍历<code>hash</code>中的数放入<code>集合set</code>中，由于集合的去重性，只需判断<code>hash</code>和<code>set</code>的长度即可。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueOccurrences</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        count = [<span class="number">0</span>] * <span class="number">2005</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        cnt = <span class="number">0</span>  <span class="comment"># 记录数组的长度，为0的元素不算在内</span></span><br><span class="line">        set1 = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> count:</span><br><span class="line">            <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            set1.add(i)</span><br><span class="line">        <span class="keyword">if</span> cnt == <span class="built_in">len</span>(set1):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>另一种写法：</p><p><code>collections.Counter(arr)是python中的计数函数</code>，不容易记住，所以不推荐使用啦</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniqueOccurrences</span>(<span class="params">self, arr: List[<span class="built_in">int</span>]</span>) -&gt; bool:</span></span><br><span class="line">        collect = collections.Counter(arr)</span><br><span class="line">        lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> collect.values():</span><br><span class="line">            lst.append(i)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(lst) == <span class="built_in">len</span>(<span class="built_in">set</span>(lst)):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
            <tag> 集合 </tag>
            
            <tag> 暴力 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两个数组的交集</title>
      <link href="2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/"/>
      <url>2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="两个数组的交集" href="https://leetcode-cn.com/problems/intersection-of-two-arrays"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">两个数组的交集</p><p class="url">https://leetcode-cn.com/problems/intersection-of-two-arrays</p></div></a></div><p>给定两个数组，编写一个函数来计算它们的交集。</p><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]</span><br><span class="line">输出：[2]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]</span><br><span class="line">输出：[9,4]</span><br></pre></td></tr></table></figure><p><strong>说明：</strong></p><ul><li>输出结果中的每个元素一定是唯一的。</li><li>我们可以不考虑输出结果的顺序。</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>注意：<strong>每个元素唯一，无顺序</strong></p><h3 id="暴力实现"><a href="#暴力实现" class="headerlink" title="暴力实现"></a>暴力实现</h3><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> nums2:</span><br><span class="line">                <span class="keyword">if</span> j == i:</span><br><span class="line">                    ans.add(j)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure><p>时间复杂度：$O(n^2)$</p><p><strong>对暴力的优化</strong></p><p>将内层循环修改</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        ans = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">                ans.add(i)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(ans)</span><br></pre></td></tr></table></figure><p>时间复杂度近似于$O(n)$吧</p><h3 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h3><p>python内置函数特性，<code>&amp;</code>运算符取交集</p><p><strong><em>AC带代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(<span class="built_in">set</span>(nums1) &amp; <span class="built_in">set</span>(nums2))</span><br></pre></td></tr></table></figure><p style="text-align:center;color:#3CB371;font-size:1.5em;font-weight: bold;"> 哈希表</p><ul><li>建立一个空的哈希表和一个空的列表，列表存放答案</li><li>哈希表的键存放<code>nums1</code>的数，值就设为<code>1</code>了，当然也可以是其他的数</li><li>遍历<code>nums2</code>，如果<code>nums2</code>的值出现在哈希表的键当中，那么把它放到答案的列表中，同时哈希表的值设为None</li><li>返回<code>ans</code>即可</li></ul><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intersection</span>(<span class="params">self, nums1: List[<span class="built_in">int</span>], nums2: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        ans = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums1:</span><br><span class="line">            <span class="keyword">if</span> dic.get(i) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                dic[i] = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums2:</span><br><span class="line">            <span class="keyword">if</span> dic.get(i) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                ans.append(i)</span><br><span class="line">                dic[i] = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure><p>时间复杂度$O(n)$</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快乐数</title>
      <link href="2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/"/>
      <url>2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="快乐数" href="https://leetcode-cn.com/problems/happy-number"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">快乐数</p><p class="url">https://leetcode-cn.com/problems/happy-number</p></div></a></div><p>编写一个算法来判断一个数 <code>n</code> 是不是快乐数。</p><p>「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是<strong>无限循环</strong>但始终变不到 1。如果<strong>可以变为</strong> 1，那么这个数就是快乐数。</p><p>如果 <code>n</code> 是快乐数就返回 <code>True</code> ；不是，则返回 <code>False</code> 。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：19</span><br><span class="line">输出：true</span><br><span class="line">解释：</span><br><span class="line">12 + 92 &#x3D; 82</span><br><span class="line">82 + 22 &#x3D; 68</span><br><span class="line">62 + 82 &#x3D; 100</span><br><span class="line">12 + 02 + 02 &#x3D; 1</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，现在看一个不是快乐数的情况。</p><p>比如数字<code>11</code>的计算过程：</p><p>$1^2 + 1^2 = 2$<br>$2^2 = 4$<br>$4^2 = 16$<br>$1^2 + 6^2 = 37$<br>$3^2 + 7^2 = 58$<br>$5^2 + 8^2 = 89$<br>$8^2 + 9^2 = 145$<br>$1^2 + 4^2 + 5^2 = 42$<br>$4^2 + 2^2 = 20$<br>$2^2 + 0^2 = $<code>4</code></p><p>可以发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用 <strong>哈希表</strong>来记录所有出现过的数字，然后每出现一个新数字，在 <strong>哈希表</strong>中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回<code>True</code></p><h3 id="哈希迭代"><a href="#哈希迭代" class="headerlink" title="哈希迭代"></a>哈希迭代</h3><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        visited = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> n <span class="keyword">not</span> <span class="keyword">in</span> visited:</span><br><span class="line">            visited.add(n)</span><br><span class="line">            temp = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> n != <span class="number">0</span>:</span><br><span class="line">                temp += (n % <span class="number">10</span>) ** <span class="number">2</span></span><br><span class="line">                n //= <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> temp == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            n = temp</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="循环迭代"><a href="#循环迭代" class="headerlink" title="循环迭代"></a>循环迭代</h3><p>经过上面的分析，对于一个非快乐数，其<strong>数位平方和</strong>最终会进入<code>4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4</code>的循环中。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = <span class="built_in">sum</span>([<span class="built_in">int</span>(i)**<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(n)])</span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">4</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">            <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><hr><p>下面的不用看：没弄明白</p><hr><p>在基于上面的解法后，怕耗时太多，于是我设置了一个k，用k作为每次<strong>计算数位平方和</strong>的循环计数，当这个数是快乐数时，计算<strong>数位平方和</strong>的次数一定会有限步内（至于是几步有待考证，这里我k计算到了第6步AC了）计算完收敛到1，但是没有明确的数学证明，我猜想可能是判题时给出的数字太小吧，所以巧过，哈哈哈。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isHappy</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; bool:</span></span><br><span class="line">        temp = <span class="built_in">str</span>(n)</span><br><span class="line">        k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">str</span>(temp):</span><br><span class="line">                <span class="built_in">sum</span> += <span class="built_in">int</span>(i) * <span class="built_in">int</span>(i)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            temp = <span class="built_in">str</span>(<span class="built_in">sum</span>)</span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> k &gt; <span class="number">5</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数学 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>加一</title>
      <link href="2020/11/26/%E5%8A%A0%E4%B8%80/"/>
      <url>2020/11/26/%E5%8A%A0%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="加一" href="https://leetcode-cn.com/problems/plus-one"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">加一</p><p class="url">https://leetcode-cn.com/problems/plus-one</p></div></a></div><p>给定一个由<strong>整数</strong>组成的<strong>非空</strong>数组所表示的非负整数，在该数的基础上加一。</p><p>最高位数字存放在数组的首位， 数组中每个元素只存储<strong>单个</strong>数字。</p><p>你可以假设除了整数 0 之外，这个整数不会以零开头。</p><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3]</span><br><span class="line">输出: [1,2,4]</span><br><span class="line">解释: 输入数组表示数字 123。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [4,3,2,1]</span><br><span class="line">输出: [4,3,2,2]</span><br><span class="line">解释: 输入数组表示数字 4321。</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="投机取巧"><a href="#投机取巧" class="headerlink" title="投机取巧"></a>投机取巧</h3><p>将<code>digits</code>各个元素转化为整数，整数自加1，转化为字符串列表<br>再将字符串列表转化为整型列表，返回即可</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        digits.reverse()</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        cnt = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> digits:</span><br><span class="line">            ans += i * cnt</span><br><span class="line">            cnt *= <span class="number">10</span></span><br><span class="line">        result = <span class="built_in">list</span>(<span class="built_in">str</span>(ans + <span class="number">1</span>))</span><br><span class="line">        out = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> result:</span><br><span class="line">            out.append(<span class="built_in">int</span>(i))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><h3 id="正常解法"><a href="#正常解法" class="headerlink" title="正常解法"></a>正常解法</h3><p>从后往前依次判断末尾是否为9，如果为9加1后要置为0，继续判断前一位，判断到<code>digits</code>的第一位都是9时，在<code>digits</code>第一位插入1结束；不为9加1后直接返回即可。</p><p><strong><em>AC代码</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">plusOne</span>(<span class="params">self, digits: List[<span class="built_in">int</span>]</span>) -&gt; List[int]:</span></span><br><span class="line">        l = <span class="built_in">len</span>(digits)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, l):</span><br><span class="line">            digits[l - i - <span class="number">1</span>] = (digits[l - i - <span class="number">1</span>] + <span class="number">1</span>) % <span class="number">10</span></span><br><span class="line">            <span class="keyword">if</span> digits[l - i - <span class="number">1</span>] != <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> digits</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        digits.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> digits</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数之和</title>
      <link href="2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/"/>
      <url>2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>题目传送门：</p><div class="tag link"><a class="link-card" title="两数之和" href="https://leetcode-cn.com/problems/two-sum/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">两数之和</p><p class="url">https://leetcode-cn.com/problems/two-sum/</p></div></a></div><p>给定一个整数数组<code>nums</code>和一个目标值 <code>target</code>，请你在该数组中找出和为目标值的那<strong>两个</strong>整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>实例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p class="note note-danger">暴力求解<p>遍历数组，判断target - num是否也在list中，如果满足，还需判断target - num的下标不能是num的下标，但此方法效率较长。</p><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        nums = <span class="built_in">list</span>(nums)</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> target - num <span class="keyword">in</span> nums <span class="keyword">and</span> nums.index(target - num) != index:</span><br><span class="line">                <span class="keyword">return</span> [index, nums.index(target - num)]</span><br></pre></td></tr></table></figure><p class="note note-danger">打表实现<p>哈希表：简单来说就是存有键值对[key, value]的一种数据结构，其查找速度是最快的。因此为了提高查找的效率，可以通过字典来模拟哈希查询，只用一次循环即可解决。</p><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: List[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; List[int]:</span></span><br><span class="line">        dic = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">for</span> index, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            temp = dic.get(target - num)</span><br><span class="line">            <span class="keyword">if</span> temp <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                <span class="keyword">return</span> [temp, index]</span><br><span class="line">            dic[num] = index</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>丢失的数字</title>
      <link href="2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>题目传送门</p><div class="tag link"><a class="link-card" title="丢失的数字" href="https://leetcode-cn.com/problems/missing-number/"><div class="left"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" class="lazyload placeholder" data-srcset="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-assets@master/logo/256/safari.png" srcset="https://cdn.jsdelivr.net/gh/Axehco/CDNforAxehco@1.0.9/images/loading.gif"/></div><div class="right"><p class="text">丢失的数字</p><p class="url">https://leetcode-cn.com/problems/missing-number/</p></div></a></div><p>给定一个包含 <code>[0, n]</code> 中 <code>n</code> 个数的数组 <code>nums</code> ，找出 <code>[0, n]</code> 这个范围内没有出现在数组中的那个数。</p><p><strong>进阶：</strong></p><ul><li>你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题?</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]</span><br><span class="line">输出：8</span><br><span class="line">解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0]</span><br><span class="line">输出：1</span><br><span class="line">解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= n</code></li><li><code>nums</code> 中的所有数字都 <strong>独一无二</strong></li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="数学解法"><a href="#数学解法" class="headerlink" title="数学解法"></a>数学解法</h3><p>先求出0到n这n+1个数的和<br>再求出nums中所有数的和<br>两者相减，得到的即为丢失的数字</p><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">int</span>((<span class="number">1</span> + <span class="built_in">len</span>(nums)) * <span class="built_in">len</span>(nums) / <span class="number">2</span>)</span><br><span class="line">        sum1 = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            sum1 += i</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span> - sum1</span><br></pre></td></tr></table></figure><h3 id="哈希表实现"><a href="#哈希表实现" class="headerlink" title="哈希表实现"></a>哈希表实现</h3><p>哈希表实现<br>产生n+1个bool型的数<br>遍历一遍，改变其值再输出即可</p><p><strong><em>AC代码：</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">missingNumber</span>(<span class="params">self, nums: List[<span class="built_in">int</span>]</span>) -&gt; int:</span></span><br><span class="line">        Hash = [<span class="literal">True</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(nums) + <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            Hash[i] = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(Hash):</span><br><span class="line">            <span class="keyword">if</span> j:</span><br><span class="line">                <span class="keyword">return</span> i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> Python </tag>
            
            <tag> 数学 </tag>
            
            <tag> 哈希表 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
