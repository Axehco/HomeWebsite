{"meta":{"title":"AXEHCO'S BLOG","subtitle":"","description":"","author":"Axehco","url":"https://Axehco.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-14T06:02:47.088Z","updated":"2020-11-14T06:02:47.088Z","comments":true,"path":"404.html","permalink":"https://axehco.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"技术大佬","date":"2020-11-18T07:35:17.028Z","updated":"2020-11-18T07:35:17.028Z","comments":false,"path":"friends/index.html","permalink":"https://axehco.github.io/friends/index.html","excerpt":"博主还未添加任何友链哟，去看看其他吧~","text":"博主还未添加任何友链哟，去看看其他吧~"},{"title":"所有分类","date":"2020-11-14T15:39:25.493Z","updated":"2020-11-14T15:39:25.493Z","comments":true,"path":"categories/index.html","permalink":"https://axehco.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-14T05:44:31.206Z","updated":"2020-11-14T05:44:31.206Z","comments":true,"path":"tags/index.html","permalink":"https://axehco.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-14T05:45:32.376Z","updated":"2020-11-14T05:45:32.376Z","comments":true,"path":"mylist/index.html","permalink":"https://axehco.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"独一无二的出现次数","slug":"独一无二的出现次数","date":"2020-11-26T04:24:39.000Z","updated":"2020-11-26T04:26:35.338Z","comments":false,"path":"2020/11/26/独一无二的出现次数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/","excerpt":"集合的去重你还能想起吗？","text":"题目描述题目传送门： 独一无二的出现次数https://leetcode-cn.com/problems/unique-number-of-occurrences/ 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr &#x3D; [1,2]输出：false 示例 3： 12输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 题解暴力实现建立一个范围为-1000到1000的数组hash，遍历arr，对arr的元素计数，在遍历一遍hash，找是否存在相同的两个不为0的数即可。 AC代码 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hash = [0] * 2005 for i in arr: hash[i] += 1 for i, j in enumerate(hash): for m, n in enumerate(hash): if m != i and j == n and n != 0: return False return True 用此这种势必会消耗大量的时间和空间了 下面采用另外一种方式 排序+集合先排序数组，然后扫描每一个元素的出现次数并加入set，发现重复次数时返回false，遍历结束后返回true。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 count.sort(reverse = True) set1 = set() for i in count: if i == 0: break else: if i in set1: return False else: set1.add(i) return True 你还记得集合的去重功能吗？还可以这样解： 先计算每个数出现的次数，放在数组hash中，再遍历hash中的数放入集合set中，由于集合的去重性，只需判断hash和set的长度即可。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 cnt = 0 # 记录数组的长度，为0的元素不算在内 set1 = set() for i in count: if i == 0: continue cnt += 1 set1.add(i) if cnt == len(set1): return True else: return False 另一种写法： collections.Counter(arr)是python中的计数函数，不容易记住，所以不推荐使用啦 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: collect = collections.Counter(arr) lst = [] for i in collect.values(): lst.append(i) if len(lst) == len(set(lst)): return True return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"两个数组的交集","slug":"两个数组的交集","date":"2020-11-26T04:22:20.000Z","updated":"2020-11-26T04:23:57.722Z","comments":false,"path":"2020/11/26/两个数组的交集/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"范围太大还能用哈希表吗？","text":"题目描述题目传送门： 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2] 示例 2： 12输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解注意：每个元素唯一，无顺序 暴力实现AC代码 12345678class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: for j in nums2: if j == i: ans.add(j) return list(ans) 时间复杂度：$O(n^2)$ 对暴力的优化 将内层循环修改 AC代码 1234567class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: if i in nums2: ans.add(i) return list(ans) 时间复杂度近似于$O(n)$吧 内置函数python内置函数特性，&amp;运算符取交集 AC带代码 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 哈希表 建立一个空的哈希表和一个空的列表，列表存放答案 哈希表的键存放nums1的数，值就设为1了，当然也可以是其他的数 遍历nums2，如果nums2的值出现在哈希表的键当中，那么把它放到答案的列表中，同时哈希表的值设为None 返回ans即可 AC代码 123456789101112class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic = dict() ans = [] for i in nums1: if dic.get(i) is None: dic[i] = 1 for i in nums2: if dic.get(i) is not None: ans.append(i) dic[i] = None return ans 时间复杂度$O(n)$","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"快乐数","slug":"快乐数","date":"2020-11-26T04:19:46.000Z","updated":"2020-11-26T04:21:49.459Z","comments":false,"path":"2020/11/26/快乐数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"哈希迭代，真的快乐吗？","text":"题目描述题目传送门： 快乐数https://leetcode-cn.com/problems/happy-number 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 1234567输入：19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 题解这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，现在看一个不是快乐数的情况。 比如数字11的计算过程： $1^2 + 1^2 = 2$$2^2 = 4$$4^2 = 16$$1^2 + 6^2 = 37$$3^2 + 7^2 = 58$$5^2 + 8^2 = 89$$8^2 + 9^2 = 145$$1^2 + 4^2 + 5^2 = 42$$4^2 + 2^2 = 20$$2^2 + 0^2 = $4 可以发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用 哈希表来记录所有出现过的数字，然后每出现一个新数字，在 哈希表中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回True 哈希迭代AC代码 12345678910111213class Solution: def isHappy(self, n: int) -&gt; bool: visited = set() while n not in visited: visited.add(n) temp = 0 while n != 0: temp += (n % 10) ** 2 n //= 10 if temp == 1: return True n = temp return False 循环迭代经过上面的分析，对于一个非快乐数，其数位平方和最终会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的循环中。 AC代码 12345678class Solution: def isHappy(self, n: int) -&gt; bool: while True: n = sum([int(i)**2 for i in str(n)]) if n == 4: return False if n == 1: return True 下面的不用看：没弄明白 在基于上面的解法后，怕耗时太多，于是我设置了一个k，用k作为每次计算数位平方和的循环计数，当这个数是快乐数时，计算数位平方和的次数一定会有限步内（至于是几步有待考证，这里我k计算到了第6步AC了）计算完收敛到1，但是没有明确的数学证明，我猜想可能是判题时给出的数字太小吧，所以巧过，哈哈哈。 AC代码 1234567891011121314class Solution: def isHappy(self, n: int) -&gt; bool: temp = str(n) k = 0 while True: sum = 0 for i in str(temp): sum += int(i) * int(i) if sum == 1: return True temp = str(sum) k += 1 if k &gt; 5: return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"加一","slug":"加一","date":"2020-11-26T04:09:43.000Z","updated":"2020-11-26T04:19:08.445Z","comments":false,"path":"2020/11/26/加一/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%8A%A0%E4%B8%80/","excerpt":"简单的数组操作题","text":"题目描述题目传送门： 加一https://leetcode-cn.com/problems/plus-one 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题解投机取巧将digits各个元素转化为整数，整数自加1，转化为字符串列表再将字符串列表转化为整型列表，返回即可 AC代码 12345678910111213class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: digits.reverse() ans = 0 cnt = 1 for i in digits: ans += i * cnt cnt *= 10 result = list(str(ans + 1)) out = [] for i in result: out.append(int(i)) return out 正常解法从后往前依次判断末尾是否为9，如果为9加1后要置为0，继续判断前一位，判断到digits的第一位都是9时，在digits第一位插入1结束；不为9加1后直接返回即可。 AC代码 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: l = len(digits) for i in range(0, l): digits[l - i - 1] = (digits[l - i - 1] + 1) % 10 if digits[l - i - 1] != 0: return digits else: continue digits.insert(0, 1) return digits","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-11-15T07:54:11.000Z","updated":"2020-11-18T04:12:32.219Z","comments":false,"path":"2020/11/15/两数之和/","link":"","permalink":"https://axehco.github.io/2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"哈希表的应用","text":"问题描述题目传送门： 两数之和https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 实例： 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解暴力求解 遍历数组，判断target - num是否也在list中，如果满足，还需判断target - num的下标不能是num的下标，但此方法效率较长。 AC代码： 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: nums = list(nums) for index, num in enumerate(nums): if target - num in nums and nums.index(target - num) != index: return [index, nums.index(target - num)] 打表实现 哈希表：简单来说就是存有键值对[key, value]的一种数据结构，其查找速度是最快的。因此为了提高查找的效率，可以通过字典来模拟哈希查询，只用一次循环即可解决。 AC代码： 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = dict() for index, num in enumerate(nums): temp = dic.get(target - num) if temp is not None: return [temp, index] dic[num] = index","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"丢失的数字","slug":"丢失的数字","date":"2020-11-14T08:55:45.000Z","updated":"2020-11-18T05:09:02.119Z","comments":false,"path":"2020/11/14/丢失的数字/","link":"","permalink":"https://axehco.github.io/2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"巧用数学思维","text":"问题描述题目传送门 丢失的数字https://leetcode-cn.com/problems/missing-number/ 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 123输入：nums &#x3D; [3,0,1]输出：2解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums &#x3D; [0,1]输出：2解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]输出：8解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums &#x3D; [0]输出：1解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 题解数学解法先求出0到n这n+1个数的和再求出nums中所有数的和两者相减，得到的即为丢失的数字 AC代码： 1234567class Solution: def missingNumber(self, nums: List[int]) -&gt; int: sum = int((1 + len(nums)) * len(nums) / 2) sum1 = 0 for i in nums: sum1 += i return sum - sum1 哈希表实现哈希表实现产生n+1个bool型的数遍历一遍，改变其值再输出即可 AC代码： 12345678class Solution: def missingNumber(self, nums: List[int]) -&gt; int: Hash = [True for i in range(len(nums) + 1)] for i in nums: Hash[i] = False for i, j in enumerate(Hash): if j: return i","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"}]}