{"meta":{"title":"AXEHCO'S BLOG","subtitle":"","description":"","author":"Axehco","url":"https://Axehco.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-27T15:30:29.155Z","updated":"2020-11-27T15:29:25.981Z","comments":true,"path":"index.html","permalink":"https://axehco.github.io/index.html","excerpt":"","text":"Sponsor-Page Sponsor PayPal Bitcoin AliPay WeChat"},{"title":"所有分类","date":"2020-11-14T15:39:25.493Z","updated":"2020-11-14T15:39:25.493Z","comments":true,"path":"categories/index.html","permalink":"https://axehco.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-11-14T05:44:31.206Z","updated":"2020-11-14T05:44:31.206Z","comments":true,"path":"tags/index.html","permalink":"https://axehco.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-14T05:45:32.376Z","updated":"2020-11-14T05:45:32.376Z","comments":true,"path":"mylist/index.html","permalink":"https://axehco.github.io/mylist/index.html","excerpt":"","text":""},{"title":"小伙伴们","date":"2020-11-28T02:49:16.000Z","updated":"2020-11-28T02:49:16.000Z","comments":false,"path":"friends/index.html","permalink":"https://axehco.github.io/friends/index.html","excerpt":"交换友链规范 title: 博客名称 avatar: 博客头像 url: 您的博客链接 您按照上面格式发送到博主qq即可：","text":"交换友链规范 title: 博客名称 avatar: 博客头像 url: 您的博客链接 您按照上面格式发送到博主qq即可："},{"title":"","date":"2020-11-14T06:02:47.088Z","updated":"2020-11-14T06:02:47.088Z","comments":true,"path":"404.html","permalink":"https://axehco.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"}],"posts":[{"title":"一个有趣的故事理解并查集","slug":"一个有趣的故事理解并查集","date":"2020-11-28T05:55:08.000Z","updated":"2020-11-28T06:00:32.688Z","comments":false,"path":"2020/11/28/一个有趣的故事理解并查集/","link":"","permalink":"https://axehco.github.io/2020/11/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"一种用于判断“远方亲戚”的算法","text":"一个超级有意思，好懂的并查集解释， 膜拜大神，找不到原著，所以算是知识剽窃了。 并查集是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。 故事读完了，并查集就会了 江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“喜羊羊同胞队”，“懒洋洋同胞对”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find()这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。 123456int find(int x)&#123; //查找我（x）的掌门 int r=x; //委托 r 去找掌门 while (pre[r ]!=r) //如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =） r=pre[r ] ; // r 就接着找他的上级，直到找到掌门为止。 return r ; //掌门驾到&#125; 再来看看join()函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？ 12345void join(int x,int y)&#123; //我想让虚竹和周芷若做朋友 int fx=find(x),fy=find(y); //虚竹的老大是玄慈，芷若MM的老大是灭绝 if(fx!=fy) //玄慈和灭绝显然不是同一个人 pre[fx ]=fy; //方丈只好委委屈屈地当了师太的手下啦&#125; 再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。 于是，问题圆满解决。。。。。。。。。 说了这么多，掌握没掌握，还得找个例题做一做呀，上才艺： 题目传送门： 畅通工程http://acm.hdu.edu.cn/showproblem.php?pid=1232 Problem Description 1某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 12345678测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 1对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 1234102998 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; const int MAXN = 1000 + 5; int pre[MAXN] = &#123;0&#125;; int Find(int x) &#123; int r = x; while (pre[r] != r) r = pre[r]; int i = x, j; while (i != r) &#123; j = pre[i]; pre[i] = r; i = j; &#125; return r;&#125; void Join(int x, int y) &#123; x = Find(x); y = Find(y); if(x != y) pre[x] = y;&#125; int main() &#123; int n, m, x, y; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; pre[i] = i;//初始化节点 &#125; while (m--) &#123;//合并每一条道路 cin &gt;&gt; x &gt;&gt; y; Join(x, y); &#125; int cnt = -1;//注意是初始化-1，因为必然有一个的根节点是自己 for(int i = 1; i &lt;= n; i++) //统计未连接的道路 if(pre[i] == i) cnt++; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://axehco.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://axehco.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法","slug":"算法","permalink":"https://axehco.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"返回倒数第k个节点","slug":"返回倒数第k个节点","date":"2020-11-26T06:10:52.000Z","updated":"2020-11-26T06:13:49.458Z","comments":false,"path":"2020/11/26/返回倒数第k个节点/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"如何找到链表中倒数第n个节点呢？","text":"题目描述题目传送门： 返回倒数第 k 个节点https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 示例： 12输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2输出： 4 说明： 给定的 k 保证是有效的。 题解 给出一个长度未知的链表，如何找到链表中倒数第n个结点? 最容易想到的当然是：先从头到尾遍历链表，统计出链表的总长度，从而计算出倒数第n个结点相当于正数第几个结点。 比如链表总长度是10，倒数第3个结点就相当于正数第8个结点。然后从头遍历链表，遍历到第8个结点，就可得到结果。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: cur = head count = 0 while cur is not None: count += 1 cur = cur.next cur = head for i in range(1, count + 1): if i == count - k + 1: return cur.val cur = cur.next 但是这种方法需要经过两次遍历才能得到结果，如果只用一次遍历，是否可以得到结果？ 当然是可以的啦 首先，我们创建两个指针p1和p2，p1指向链表的头结点，p2指向链表的正数第n个结点 。 接下来,我们让指针p1和p2同时循环右移，每次右移一步，直到指针p2移动到链表的末尾。 此时，由于p2指向链表的尾结点，且p1和p2的距离是n-1，因此p1所指的结点就是我们要寻找的链表倒数第n个结点。 显然，这个方法从头到尾只需要对链表做一次遍历，而且仅仅使用了两个指针，算法的空间复杂度是O(1)。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: p1 = head p2 = head # 把p2指针移动到正数第n个结点 for i in range(k - 1): p2 = p2.next # p1和p2一起右移，直到p2指向链表尾结点 while p2.next is not None: p1 = p1.next p2 = p2.next return p1.val","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"有效的字母异位词","slug":"有效的字母异位词","date":"2020-11-26T05:53:07.000Z","updated":"2020-11-26T07:49:42.698Z","comments":false,"path":"2020/11/26/有效的字母异位词/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"哈希表的应用","text":"题目描述题目传送门： 有效的字母异位词https://leetcode-cn.com/problems/valid-anagram/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 12输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true 示例 2: 12输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题解排序比较对两个字符串按照ASCII排序，比较是否相同 AC代码 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return True if sorted(s) == sorted(t) else False 哈希打表题目中字符串只有小写字符，那么就可以定义一个数组(哈希表)，来记录字符串s里字符出现的次数。 再遍历第二个字符串，把字符对应位置的计数减1 最后判断哈希表中元素是否全为0 AC代码 1234567891011class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: hashTable = [0] * 26 for i in s: hashTable[ord(i) - 97] += 1 for i in t: hashTable[ord(i) - 97] -= 1 for i in hashTable: if i != 0: return False return True","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"整数反转","slug":"整数反转","date":"2020-11-26T05:51:48.000Z","updated":"2020-11-27T13:06:45.399Z","comments":false,"path":"2020/11/26/整数反转/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"python中32位的有符号整数","text":"题目描述题目传送门： 整数反转https://leetcode-cn.com/problems/reverse-integer/ 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为$[2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。 题解关键点 判断整数的正负 判断反转后的整数是否溢出 AC代码： 1234567891011class Solution: def reverse(self, x: int) -&gt; int: flag = True # 标记正负数 if x &lt; 0: flag = False x = -x # 是负数，就转换为正数 x = str(x)[::-1] # 字符串反转x if not flag: x = -int(x) x = int(x) return x if -1 * pow(2, 31) &lt;= x &lt;= pow(2, 31) - 1 else 0","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2020-11-26T05:49:11.000Z","updated":"2020-11-26T07:49:18.567Z","comments":false,"path":"2020/11/26/最后一个单词的长度/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"python中split()和strip()方法","text":"题目描述题目传送门： 最后一个单词的长度https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 题解易错点 判断字符串是否为空字符串：&quot;&quot;，这种情况单词长度为0 判断字符串是否全部由形如&quot; &quot;的空格组成的，这种情况单词长度也为0 注意形如&quot;a &quot;这种情况的字符串，最后一个空格是不算在单词长度内的 思路先对空字符串和元素全是空格的字符串进行判断，用一个flag作为标记，再将字符串按&#39; &#39;进行切片处理，将切片后的“单词”长度添加到一个临时列表中，反向遍历列表，第一个不为0的元素即为最后一个单词的长度。 AC代码： 1234567891011121314151617class Solution: def lengthOfLastWord(self, s: str) -&gt; int: flag = True # 标记是否为空字符串或元素全是空格的字符串 for i in s: if i != &#x27; &#x27;: flag = False if flag: return 0 lst = s.split(&#x27; &#x27;) ans = [] for i in lst: ans.append(len(i)) # 将切片后的得到的单词长度添加到ans中 ans.reverse() # 末尾寻找“单词” for i in ans: if i == 0: continue return i 分割解法 Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 Python split() 通过指定分隔符对字符串进行切片。 AC代码： 1234class Solution: def lengthOfLastWord(self, s: str) -&gt; int: s = s.strip().split(&#x27; &#x27;) return len(s[-1])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"独一无二的出现次数","slug":"独一无二的出现次数","date":"2020-11-26T04:24:39.000Z","updated":"2020-11-26T04:26:35.338Z","comments":false,"path":"2020/11/26/独一无二的出现次数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/","excerpt":"集合的去重你还能想起吗？","text":"题目描述题目传送门： 独一无二的出现次数https://leetcode-cn.com/problems/unique-number-of-occurrences/ 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr &#x3D; [1,2]输出：false 示例 3： 12输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 题解暴力实现建立一个范围为-1000到1000的数组hash，遍历arr，对arr的元素计数，在遍历一遍hash，找是否存在相同的两个不为0的数即可。 AC代码 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hash = [0] * 2005 for i in arr: hash[i] += 1 for i, j in enumerate(hash): for m, n in enumerate(hash): if m != i and j == n and n != 0: return False return True 用此这种势必会消耗大量的时间和空间了 下面采用另外一种方式 排序+集合先排序数组，然后扫描每一个元素的出现次数并加入set，发现重复次数时返回false，遍历结束后返回true。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 count.sort(reverse = True) set1 = set() for i in count: if i == 0: break else: if i in set1: return False else: set1.add(i) return True 你还记得集合的去重功能吗？还可以这样解： 先计算每个数出现的次数，放在数组hash中，再遍历hash中的数放入集合set中，由于集合的去重性，只需判断hash和set的长度即可。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 cnt = 0 # 记录数组的长度，为0的元素不算在内 set1 = set() for i in count: if i == 0: continue cnt += 1 set1.add(i) if cnt == len(set1): return True else: return False 另一种写法： collections.Counter(arr)是python中的计数函数，不容易记住，所以不推荐使用啦 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: collect = collections.Counter(arr) lst = [] for i in collect.values(): lst.append(i) if len(lst) == len(set(lst)): return True return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"两个数组的交集","slug":"两个数组的交集","date":"2020-11-26T04:22:20.000Z","updated":"2020-11-26T04:23:57.722Z","comments":false,"path":"2020/11/26/两个数组的交集/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"范围太大还能用哈希表吗？","text":"题目描述题目传送门： 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2] 示例 2： 12输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解注意：每个元素唯一，无顺序 暴力实现AC代码 12345678class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: for j in nums2: if j == i: ans.add(j) return list(ans) 时间复杂度：$O(n^2)$ 对暴力的优化 将内层循环修改 AC代码 1234567class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: if i in nums2: ans.add(i) return list(ans) 时间复杂度近似于$O(n)$吧 内置函数python内置函数特性，&amp;运算符取交集 AC带代码 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 哈希表 建立一个空的哈希表和一个空的列表，列表存放答案 哈希表的键存放nums1的数，值就设为1了，当然也可以是其他的数 遍历nums2，如果nums2的值出现在哈希表的键当中，那么把它放到答案的列表中，同时哈希表的值设为None 返回ans即可 AC代码 123456789101112class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic = dict() ans = [] for i in nums1: if dic.get(i) is None: dic[i] = 1 for i in nums2: if dic.get(i) is not None: ans.append(i) dic[i] = None return ans 时间复杂度$O(n)$","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"快乐数","slug":"快乐数","date":"2020-11-26T04:19:46.000Z","updated":"2020-11-26T04:21:49.459Z","comments":false,"path":"2020/11/26/快乐数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"哈希迭代，真的快乐吗？","text":"题目描述题目传送门： 快乐数https://leetcode-cn.com/problems/happy-number 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 1234567输入：19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 题解这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，现在看一个不是快乐数的情况。 比如数字11的计算过程： $1^2 + 1^2 = 2$$2^2 = 4$$4^2 = 16$$1^2 + 6^2 = 37$$3^2 + 7^2 = 58$$5^2 + 8^2 = 89$$8^2 + 9^2 = 145$$1^2 + 4^2 + 5^2 = 42$$4^2 + 2^2 = 20$$2^2 + 0^2 = $4 可以发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用 哈希表来记录所有出现过的数字，然后每出现一个新数字，在 哈希表中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回True 哈希迭代AC代码 12345678910111213class Solution: def isHappy(self, n: int) -&gt; bool: visited = set() while n not in visited: visited.add(n) temp = 0 while n != 0: temp += (n % 10) ** 2 n //= 10 if temp == 1: return True n = temp return False 循环迭代经过上面的分析，对于一个非快乐数，其数位平方和最终会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的循环中。 AC代码 12345678class Solution: def isHappy(self, n: int) -&gt; bool: while True: n = sum([int(i)**2 for i in str(n)]) if n == 4: return False if n == 1: return True 下面的不用看：没弄明白 在基于上面的解法后，怕耗时太多，于是我设置了一个k，用k作为每次计算数位平方和的循环计数，当这个数是快乐数时，计算数位平方和的次数一定会有限步内（至于是几步有待考证，这里我k计算到了第6步AC了）计算完收敛到1，但是没有明确的数学证明，我猜想可能是判题时给出的数字太小吧，所以巧过，哈哈哈。 AC代码 1234567891011121314class Solution: def isHappy(self, n: int) -&gt; bool: temp = str(n) k = 0 while True: sum = 0 for i in str(temp): sum += int(i) * int(i) if sum == 1: return True temp = str(sum) k += 1 if k &gt; 5: return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"加一","slug":"加一","date":"2020-11-26T04:09:43.000Z","updated":"2020-11-26T04:19:08.445Z","comments":false,"path":"2020/11/26/加一/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%8A%A0%E4%B8%80/","excerpt":"简单的数组操作题","text":"题目描述题目传送门： 加一https://leetcode-cn.com/problems/plus-one 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题解投机取巧将digits各个元素转化为整数，整数自加1，转化为字符串列表再将字符串列表转化为整型列表，返回即可 AC代码 12345678910111213class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: digits.reverse() ans = 0 cnt = 1 for i in digits: ans += i * cnt cnt *= 10 result = list(str(ans + 1)) out = [] for i in result: out.append(int(i)) return out 正常解法从后往前依次判断末尾是否为9，如果为9加1后要置为0，继续判断前一位，判断到digits的第一位都是9时，在digits第一位插入1结束；不为9加1后直接返回即可。 AC代码 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: l = len(digits) for i in range(0, l): digits[l - i - 1] = (digits[l - i - 1] + 1) % 10 if digits[l - i - 1] != 0: return digits else: continue digits.insert(0, 1) return digits","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-11-15T07:54:11.000Z","updated":"2020-11-18T04:12:32.219Z","comments":false,"path":"2020/11/15/两数之和/","link":"","permalink":"https://axehco.github.io/2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"哈希表的应用","text":"问题描述题目传送门： 两数之和https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 实例： 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解暴力求解 遍历数组，判断target - num是否也在list中，如果满足，还需判断target - num的下标不能是num的下标，但此方法效率较长。 AC代码： 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: nums = list(nums) for index, num in enumerate(nums): if target - num in nums and nums.index(target - num) != index: return [index, nums.index(target - num)] 打表实现 哈希表：简单来说就是存有键值对[key, value]的一种数据结构，其查找速度是最快的。因此为了提高查找的效率，可以通过字典来模拟哈希查询，只用一次循环即可解决。 AC代码： 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = dict() for index, num in enumerate(nums): temp = dic.get(target - num) if temp is not None: return [temp, index] dic[num] = index","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"丢失的数字","slug":"丢失的数字","date":"2020-11-14T08:55:45.000Z","updated":"2020-11-18T05:09:02.119Z","comments":false,"path":"2020/11/14/丢失的数字/","link":"","permalink":"https://axehco.github.io/2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"巧用数学思维","text":"问题描述题目传送门 丢失的数字https://leetcode-cn.com/problems/missing-number/ 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 123输入：nums &#x3D; [3,0,1]输出：2解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums &#x3D; [0,1]输出：2解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]输出：8解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums &#x3D; [0]输出：1解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 题解数学解法先求出0到n这n+1个数的和再求出nums中所有数的和两者相减，得到的即为丢失的数字 AC代码： 1234567class Solution: def missingNumber(self, nums: List[int]) -&gt; int: sum = int((1 + len(nums)) * len(nums) / 2) sum1 = 0 for i in nums: sum1 += i return sum - sum1 哈希表实现哈希表实现产生n+1个bool型的数遍历一遍，改变其值再输出即可 AC代码： 12345678class Solution: def missingNumber(self, nums: List[int]) -&gt; int: Hash = [True for i in range(len(nums) + 1)] for i in nums: Hash[i] = False for i, j in enumerate(Hash): if j: return i","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]}],"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://axehco.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://axehco.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法","slug":"算法","permalink":"https://axehco.github.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]}