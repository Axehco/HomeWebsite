{"meta":{"title":"AXEHCO'S BLOG","subtitle":"","description":"","author":"Mr.Zhong","url":"https://Axehco.github.io/HomeWebsite","root":"/"},"pages":[{"title":"","date":"2021-09-25T06:36:52.645Z","updated":"2020-11-14T06:02:47.088Z","comments":true,"path":"404.html","permalink":"https://axehco.github.io/HomeWebsite/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2021-09-30T02:30:01.583Z","updated":"2021-09-30T02:30:01.583Z","comments":true,"path":"baidu_verify_code-Nmh59UALLh.html","permalink":"https://axehco.github.io/HomeWebsite/baidu_verify_code-Nmh59UALLh.html","excerpt":"","text":"25106157292fa0b1ef10fe5ee2dd29c8"},{"title":"所有分类","date":"2021-09-25T06:36:52.647Z","updated":"2020-11-14T15:39:25.493Z","comments":true,"path":"categories/index.html","permalink":"https://axehco.github.io/HomeWebsite/categories/index.html","excerpt":"","text":""},{"title":"小伙伴们","date":"2021-09-25T06:36:52.648Z","updated":"2020-12-01T11:31:52.310Z","comments":true,"path":"friends/index.html","permalink":"https://axehco.github.io/HomeWebsite/friends/index.html","excerpt":"要添加友链的朋友按照下面格式给我留言哦😘 123456items:- title: # 博客名【必填】 avatar: # 头像链接【必填】 url: # 博客链接【必填】 keywords: # 标签 description: # 博客简单描述","text":"要添加友链的朋友按照下面格式给我留言哦😘 123456items:- title: # 博客名【必填】 avatar: # 头像链接【必填】 url: # 博客链接【必填】 keywords: # 标签 description: # 博客简单描述"},{"title":"所有标签","date":"2021-09-25T06:36:52.651Z","updated":"2020-11-14T05:44:31.206Z","comments":true,"path":"tags/index.html","permalink":"https://axehco.github.io/HomeWebsite/tags/index.html","excerpt":"","text":""},{"title":"","date":"2021-09-25T06:36:52.650Z","updated":"2020-11-14T05:45:32.376Z","comments":true,"path":"mylist/index.html","permalink":"https://axehco.github.io/HomeWebsite/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"实现strStr","slug":"实现strStr","date":"2021-10-01T02:24:45.000Z","updated":"2021-10-04T14:23:43.004Z","comments":false,"path":"2021/10/01/实现strStr/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2021/10/01/%E5%AE%9E%E7%8E%B0strStr/","excerpt":"Leetcode 简单 28","text":"题目描述题目传送门： 实现strStrhttps://leetcode-cn.com/problems/implement-strstr/ 实现 strStr() 函数。 给你两个字符串 haystack和 needle，请你在 haystack 字符串中找出 needle字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回-1。 说明： 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与 C 语言的 strstr() 以及 Java 的 indexOf() 定义相符。 示例 1： 12输入：haystack &#x3D; &quot;hello&quot;, needle &#x3D; &quot;ll&quot;输出：2 示例 2： 12输入：haystack &#x3D; &quot;aaaaa&quot;, needle &#x3D; &quot;bba&quot;输出：-1 示例 3： 12输入：haystack &#x3D; &quot;&quot;, needle &#x3D; &quot;&quot;输出：0 提示： 0 &lt;= haystack.length, needle.length &lt;= 5 * 10^4 haystack 和 needle 仅由小写英文字符组成 题解暴力破解 先判断特殊情况： needle长度为0的直接返回0 对于haystack字符串长度小于needle长度的，不存在匹配，直接返回-1 遍历一遍haystack，先找到needle中第一个相匹配的字符串，再在haystack中取出与needle相等长度的字符串进行匹配即可。这里注意一个知识点，是针对python字符串切片的： 12345a &#x3D; &#39;12345&#39;a[1: 4]，从下标0开始，左闭右开得到 234a[1: 100]，此时也只能得到 2345 注意这一点！！！ 所以说不用去判断得到相等字符后，haystack后面剩下的字符长度是否要大于needle的长度。 AC代码 1234567891011class Solution: def strStr(self, haystack: str, needle: str) -&gt; int: if len(needle) == 0: return 0 if len(haystack) &lt; len(needle): return -1 for i in range(len(haystack)): if haystack[i] == needle[0]: if haystack[i: i+len(needle)] == needle: return i return -1 KMP解法本题是一个经典的KMP算法题 KMP思路：当出现字符串不匹配时，可以记录一部分之前已经匹配的文本内容，利用这些信息避免从头再去做匹配。 AC代码 123456789101112131415161718192021222324252627class Solution: def getnext(self, needle): nxt = list() nxt.append(0) j = 0 # j指向前缀起始位置 # i指向后缀起始位置 for i in range(1, len(needle)): # 注意i从1开始 while j &gt; 0 and needle[i] != needle[j]: # 前后缀不相同的情况 j = nxt[j-1] # 向前回退 if needle[i] == needle[j]: # 找到相同的后缀 j += 1 nxt.append(j) # 将j（前缀的长度）赋给next[i] return nxt def strStr(self, haystack: str, needle: str) -&gt; int: if len(needle) == 0: return 0 nxt = self.getnext(needle) j = 0 for i in range(len(haystack)): # 注意i就从0开始 while j &gt; 0 and haystack[i] != needle[j]: # 不匹配 j = nxt[j - 1] # j寻找之前匹配的位置 if haystack[i] == needle[j]: # 匹配，j和i同时向后移动 j += 1 # i的增加在for循环里 if j == len(needle): # 文本串haystack里出现了模式串needle return i - len(needle) + 1 return -1","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"KMP","slug":"KMP","permalink":"https://axehco.github.io/HomeWebsite/tags/KMP/"}]},{"title":"二进制求和","slug":"二进制求和","date":"2021-09-30T00:50:27.000Z","updated":"2021-09-30T00:57:20.284Z","comments":false,"path":"2021/09/30/二进制求和/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2021/09/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B1%82%E5%92%8C/","excerpt":"Leetcode 简单 67","text":"题目描述题目传送门： 二进制求和https://leetcode-cn.com/problems/add-binary/ 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a &#x3D; &quot;11&quot;, b &#x3D; &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a &#x3D; &quot;1010&quot;, b &#x3D; &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 题解先在比较短的字符串前面补0，使其长度一样 从末尾遍历字符串，判断各个位数上的和，情况有和&lt;2，和=2，和=3，分别讨论即可 最后对得到的字符串去掉前置的0进行return即可。 AC代码 12345678910111213141516171819202122232425class Solution: def addBinary(self, a: str, b: str) -&gt; str: if len(a) &gt; len(b): b = &quot;0&quot; * (len(a) - len(b)) + b else: a = &quot;0&quot; * (len(b) - len(a)) + a ans = &#x27;&#x27; flag = False for i in range(len(a)-1, -1, -1): if not flag: c = int(a[i]) + int(b[i]) else: c = int(a[i]) + int(b[i]) + 1 if c == 2: ans += &#x27;0&#x27; flag = True elif c == 3: ans += &#x27;1&#x27; flag = True else: flag = False ans += str(c) if i == 0 and flag: ans += &#x27;1&#x27; return str(int(ans[::-1]))","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"二进制","slug":"二进制","permalink":"https://axehco.github.io/HomeWebsite/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]},{"title":"验证回文串","slug":"验证回文串","date":"2021-09-29T00:58:14.000Z","updated":"2021-09-30T00:58:38.836Z","comments":false,"path":"2021/09/29/验证回文串/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2021/09/29/%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/","excerpt":"Leetcode 简单 125","text":"题目描述题目传送门： 验证回文串https://leetcode-cn.com/problems/valid-palindrome/ 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 123输入: &quot;A man, a plan, a canal: Panama&quot;输出: true解释：&quot;amanaplanacanalpanama&quot; 是回文串 示例 2: 123输入: &quot;race a car&quot;输出: false解释：&quot;raceacar&quot; 不是回文串 提示： 1 &lt;= s.length &lt;= 2 * 10^5 字符串 s 由 ASCII 字符组成 题解先取出数字和字符串、统一将字符串转换为小写，在进行处理即可。 AC代码： 123456789101112class Solution: def isPalindrome(self, s: str) -&gt; bool: def func(lstr): for i in range(len(lstr) // 2): if lstr[i] != lstr[len(lstr)-i-1]: return False return True temp = &#x27;&#x27; for i in s: if i.isalpha() or i.isdigit(): temp += i.lower() return func(temp)","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"SqrtX","slug":"SqrtX","date":"2021-09-28T01:08:54.000Z","updated":"2021-09-29T01:29:42.038Z","comments":false,"path":"2021/09/28/SqrtX/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2021/09/28/SqrtX/","excerpt":"Leetcode 简单 69","text":"题目描述题目传送门： SqrtXhttps://leetcode-cn.com/problems/sqrtx 给你一个非负整数 x ，计算并返回 x 的 算术平方根 。 由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。 注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。 示例 1： 12输入：x &#x3D; 4输出：2 示例 2： 123输入：x = 8输出：2解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 提示： 0 &lt;= x &lt;= 2^31 - 1 题解对于0和1进行单独判断，从1开始遍历到x的一半，进行判断即可。 暴力实现AC代码 123456789class Solution: def mySqrt(self, x: int) -&gt; int: if x == 0: return 0 if x == 1: return 1 for i in range(1, x // 2 + 1): if i * i &lt;= x &lt; (i + 1) * (i + 1): return i","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"循环","slug":"循环","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%BE%AA%E7%8E%AF/"}]},{"title":"有多少小于当前数字的数字","slug":"有多少小于当前数字的数字","date":"2021-01-01T02:57:29.000Z","updated":"2021-09-29T01:34:41.977Z","comments":false,"path":"2021/01/01/有多少小于当前数字的数字/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2021/01/01/%E6%9C%89%E5%A4%9A%E5%B0%91%E5%B0%8F%E4%BA%8E%E5%BD%93%E5%89%8D%E6%95%B0%E5%AD%97%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"Leetcode 简单 1365","text":"题目描述题目传送门： 有多少小于当前数字的数字https://leetcode-cn.com/problems/how-many-numbers-are-smaller-than-the-current-number/ 给你一个数组 nums，对于其中每个元素 nums[i]，请你统计数组中比它小的所有数字的数目。 换而言之，对于每个 nums[i] 你必须计算出有效的 j 的数量，其中 j 满足 j != i 且 nums[j] &lt; nums[i] 。 以数组形式返回答案。 示例 1： 12345678输入：nums &#x3D; [8,1,2,2,3]输出：[4,0,1,1,3]解释： 对于 nums[0]&#x3D;8 存在四个比它小的数字：（1，2，2 和 3）。 对于 nums[1]&#x3D;1 不存在比它小的数字。对于 nums[2]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[3]&#x3D;2 存在一个比它小的数字：（1）。 对于 nums[4]&#x3D;3 存在三个比它小的数字：（1，2 和 2）。 示例 2： 12输入：nums &#x3D; [6,5,4,8]输出：[2,1,0,3] 示例 3： 12输入：nums &#x3D; [7,7,7,7]输出：[0,0,0,0] 提示： 122 &lt;&#x3D; nums.length &lt;&#x3D; 5000 &lt;&#x3D; nums[i] &lt;&#x3D; 100 题解暴力实现最简单粗暴的方式：采用暴力实现，二重循环遍历数组即可，即两层for循环暴力查找，时间复杂度明显为$O(n^2)$。 AC代码 12345678910class Solution: def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]: ans = [] for index1, value1 in enumerate(nums): count = 0 for index2, value2 in enumerate(nums): if index1 != index2 and value1 &gt; value2: count += 1 ans.append(count) return ans 但是采用这种方式，因为涉及二重循环，其时间复杂度太高，不建议采取。 计数排序这种方法只需要遍历一遍待排数组即可，具体思路如下： 提前建立一个从0-100的空数组用来计数，在待排数组里遇到一个数就在计数数组里对应位置+1。 题目要求比此数小的，也就是刚才的计数数组里，当前位置（表示对应的nums里的一个数n），之前的数（比n小的数字的个数）的总和。理解不了没关系，看一遍代码就懂了。 AC代码 1234567891011121314class Solution: def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]: count = [0] * 101 # 计数数组：题目强调0 &lt;= nums[i] &lt;= 100，则最多101个空间即可 out = [] # 记录最终答案 for n in nums: count[n] += 1 # 计数器，第n个数加1 sum = 0 # 存放count数组的累加值 ans = [] # 将比它小的数列举出进行存放 for value in count: ans.append(sum) sum += value for value in nums: out.append(ans[value]) return out 注意 计数排序可能是所有排序里最快的一种，因为它不涉及比较。 缺点：需要的空间很大。所以一般只涉及数字且范围较小的时候，还能应付，一旦涉及到字母混数字排序就无能为力了。 排序哈希首先要找小于当前数字的数字，那么从小到大排序之后，该数字之前的数字就都是比它小的了。 所以可以定义一个新数组，将数组排个序。 排序之后，其实每一个数值的下标就代表这前面有几个比它小的了。 此时有一个情况，就是数值相同怎么办？ 可以这样处理：将数组降序排列，此时要得到小于当前数字的数字，它与降序排列的下标有什么关系呢？ $$要找的小于当前数字的数字=len(nums)-1-数组下标$$ 此时再用一个哈希表hash来做数值和下标的映射，这样就可以通过数值快速知道下标。 AC代码 12345678910class Solution: def smallerNumbersThanCurrent(self, nums: List[int]) -&gt; List[int]: out = [] temp = sorted(nums, reverse=True) # 降序排列 hash = [0] * 101 # 根据题意，哈希表最多101个空间即可 for i, j in enumerate(temp): hash[j] = len(nums) - 1 - i # 此写法为了避免nums中有相同的数 for i in nums: out.append(hash[i]) return out","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"计数排序","slug":"计数排序","permalink":"https://axehco.github.io/HomeWebsite/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"}]},{"title":"搜索插入位置","slug":"搜索插入位置","date":"2020-11-28T06:05:00.000Z","updated":"2021-09-29T01:34:04.320Z","comments":false,"path":"2020/11/28/搜索插入位置/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/28/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE/","excerpt":"Leetcode 简单 35","text":"题目描述题目传送门： 搜索插入位置https://leetcode-cn.com/problems/search-insert-position/ 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 题解要在数组中插入目标值，只有一下四种情况： 目标值在数组所有元素之前 目标值等于数组中某一个元素 目标值插入数组中的位置 目标值在数组所有元素之后 暴力实现直接遍历数组即可 AC代码 123456class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: for index, num in enumerate(nums): if target &lt;= num: return index return len(nums) 时间复杂度：$O(n)$空间复杂度：$O(1)$ 二分查找首先要注意：二分的条件是数组有序，本题满足条件 同时题目还强调数组中无重复元素，因为一旦有重复元素，使用二分查找法返回的元素下标可能不是唯一的。 既然暴力解法的时间复杂度是$O(n)$，就要尝试一下使用二分查找法。 二分查找涉及的很多的边界条件，逻辑比较简单，但是稍不注意，就会弄错。 while(left &lt; right)与while(left &lt;= right)采用哪种写法？ right = middle与right = middle - 1又采用哪种写法? 这里弄不清楚主要是因为对区间的定义没有想清楚，这就是不变量。 要在二分查找的过程中，保持不变量，这也就是循环不变量 第一种写法：定义 target 是在一个在左闭右闭的区间里，即**[left, right]** ​ AC代码 注意为什么要写while(left &lt;= right)和right = middle - 1 12345678910111213141516171819class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left = 0 right = len(nums) - 1 # 定义target在左闭右闭的区间里，[left, right] while(left &lt;= right): # 当left==right，区间[left, right]依然有效 mid = left + (right - left) // 2 # 为了防止left + right溢出,和(left + right)/2效果一样 if target == nums[mid]: return mid elif target &lt; nums[mid]: right = mid - 1 # target 在左区间，所以[left, middle - 1] else: left = mid + 1 # target 在右区间，所以[middle + 1, right] &quot;&quot;&quot;分别处理如下四种情况 目标值在数组所有元素之前 [0, -1] 目标值等于数组中某一个元素 return mid; 目标值插入数组中的位置 [left, right] 此时 return right + 1 目标值在数组所有元素之后的情况 [left, right] 此时 return right + 1 &quot;&quot;&quot; return right + 1 时间复杂度：$O(logn)$空间复杂度：$O(1)$ 第二种写法 AC代码 注意为什么要写while(left &lt; right)和right = middle 12345678910111213141516171819class Solution: def searchInsert(self, nums: List[int], target: int) -&gt; int: left = 0 right = len(nums) # 定义target在左闭右开的区间里，[left, right) while(left &lt; right): # 因为left == right的时候，在[left, right)是无效的空间 mid = left + (right - left) // 2 # 为了防止left + right溢出,和(left + right)/2效果一样 if target == nums[mid]: return mid # 数组中找到目标值的情况，直接返回下标 elif target &lt; nums[mid]: right = mid # 在左区间，在[left, middle)中 else: left = mid + 1 # 在右区间，在 [middle+1, right)中 &quot;&quot;&quot;分别处理如下四种情况 目标值在数组所有元素之前 [0,0) 目标值等于数组中某一个元素 return mid; 目标值插入数组中的位置 [left, right) 此时 return right 目标值在数组所有元素之后的情况 [left, right) 此时 return right &quot;&quot;&quot; return right 时间复杂度：$O(logn)$空间复杂度：$O(1)$ 参考：数组：每次遇到二分法，都是一看就会，一写就废","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"二分查找","slug":"二分查找","permalink":"https://axehco.github.io/HomeWebsite/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"}]},{"title":"一个有趣的故事理解并查集","slug":"一个有趣的故事理解并查集","date":"2020-11-28T05:55:08.000Z","updated":"2020-11-29T03:02:51.191Z","comments":false,"path":"2020/11/28/一个有趣的故事理解并查集/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/28/%E4%B8%80%E4%B8%AA%E6%9C%89%E8%B6%A3%E7%9A%84%E6%95%85%E4%BA%8B%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"一种用于判断“远方亲戚”的算法","text":"一个超级有意思，好懂的并查集解释， 膜拜大神，找不到原著，所以算是知识剽窃了。 并查集是一种树型的数据结构，用于处理一些不相交集合(Disjoint Sets)的合并及查询问题。 故事读完了，并查集就会了 江湖上散落着各式各样的大侠，有上千个之多。他们没有什么正当职业，整天背着剑在外面走来走去，碰到和自己不是一路人的，就免不了要打一架。但大侠们有一个优点就是讲义气，绝对不打自己的朋友。而且他们信奉“朋友的朋友就是我的朋友”，只要是能通过朋友关系串联起来的，不管拐了多少个弯，都认为是自己人。这样一来，江湖上就形成了一个一个的帮派，通过两两之间的朋友关系串联起来。而不在同一个帮派的人，无论如何都无法通过朋友关系连起来，于是就可以放心往死了打。但是两个原本互不相识的人，如何判断是否属于一个朋友圈呢？ 我们可以在每个朋友圈内推举出一个比较有名望的人，作为该圈子的代表人物，这样，每个圈子就可以这样命名“喜羊羊同胞队”，“懒洋洋同胞对”……两人只要互相对一下自己的队长是不是同一个人，就可以确定敌友关系了。 但是还有问题啊，大侠们只知道自己直接的朋友是谁，很多人压根就不认识队长，要判断自己的队长是谁，只能漫无目的的通过朋友的朋友关系问下去：“你是不是队长？你是不是队长？”这样一来，队长面子上挂不住了，而且效率太低，还有可能陷入无限循环中。于是队长下令，重新组队。队内所有人实行分等级制度，形成树状结构，我队长就是根节点，下面分别是二级队员、三级队员。每个人只要记住自己的上级是谁就行了。遇到判断敌友的时候，只要一层层向上问，直到最高层，就可以在短时间内确定队长是谁了。由于我们关心的只是两个人之间是否连通，至于他们是如何连通的，以及每个圈子内部的结构是怎样的，甚至队长是谁，并不重要。所以我们可以放任队长随意重新组队，只要不搞错敌友关系就好了。于是，门派产生了。 下面我们来看并查集的实现。 int pre[1000]; 这个数组，记录了每个大侠的上级是谁。大侠们从1或者0开始编号（依据题意而定），pre[15]=3就表示15号大侠的上级是3号大侠。如果一个人的上级就是他自己，那说明他就是掌门人了，查找到此为止。也有孤家寡人自成一派的，比如欧阳锋，那么他的上级就是他自己。每个人都只认自己的上级。比如胡青牛同学只知道自己的上级是杨左使。张无忌是谁？不认识！要想知道自己的掌门是谁，只能一级级查上去。 find()这个函数就是找掌门用的，意义再清楚不过了（路径压缩算法先不论，后面再说）。 123456int find(int x)&#123; //查找我（x）的掌门 int r=x; //委托 r 去找掌门 while (pre[r ]!=r) //如果r的上级不是r自己（也就是说找到的大侠他不是掌门 = =） r=pre[r ] ; // r 就接着找他的上级，直到找到掌门为止。 return r ; //掌门驾到&#125; 再来看看join()函数，就是在两个点之间连一条线，这样一来，原先它们所在的两个板块的所有点就都可以互通了。这在图上很好办，画条线就行了。但我们现在是用并查集来描述武林中的状况的，一共只有一个pre[]数组，该如何实现呢？ 还是举江湖的例子，假设现在武林中的形势如图所示。虚竹小和尚与周芷若MM是我非常喜欢的两个人物，他们的终极boss分别是玄慈方丈和灭绝师太，那明显就是两个阵营了。我不希望他们互相打架，就对他俩说：“你们两位拉拉勾，做好朋友吧。”他们看在我的面子上，同意了。这一同意可非同小可，整个少林和峨眉派的人就不能打架了。这么重大的变化，可如何实现呀，要改动多少地方？其实非常简单，我对玄慈方丈说：“大师，麻烦你把你的上级改为灭绝师太吧。这样一来，两派原先的所有人员的终极boss都是师太，那还打个球啊！反正我们关心的只是连通性，门派内部的结构不要紧的。”玄慈一听肯定火大了：“我靠，凭什么是我变成她手下呀，怎么不反过来？我抗议！”抗议无效，上天安排的，最大。反正谁加入谁效果是一样的，我就随手指定了一个。这段函数的意思很明白了吧？ 12345void join(int x,int y)&#123; //我想让虚竹和周芷若做朋友 int fx=find(x),fy=find(y); //虚竹的老大是玄慈，芷若MM的老大是灭绝 if(fx!=fy) //玄慈和灭绝显然不是同一个人 pre[fx ]=fy; //方丈只好委委屈屈地当了师太的手下啦&#125; 再来看看路径压缩算法。建立门派的过程是用join函数两个人两个人地连接起来的，谁当谁的手下完全随机。最后的树状结构会变成什么胎唇样，我也完全无法预计，一字长蛇阵也有可能。这样查找的效率就会比较低下。最理想的情况就是所有人的直接上级都是掌门，一共就两级结构，只要找一次就找到掌门了。哪怕不能完全做到，也最好尽量接近。这样就产生了路径压缩算法。 设想这样一个场景：两个互不相识的大侠碰面了，想知道能不能揍。 于是赶紧打电话问自己的上级：“你是不是掌门？” 上级说：“我不是呀，我的上级是谁谁谁，你问问他看看。” 一路问下去，原来两人的最终boss都是东厂曹公公。 “哎呀呀，原来是记己人，西礼西礼，在下三营六组白面葫芦娃!” “幸会幸会，在下九营十八组仙子狗尾巴花！” 两人高高兴兴地手拉手喝酒去了。 “等等等等，两位同学请留步，还有事情没完成呢！”我叫住他俩。 “哦，对了，还要做路径压缩。”两人醒悟。 白面葫芦娃打电话给他的上级六组长：“组长啊，我查过了，其习偶们的掌门是曹公公。不如偶们一起及接拜在曹公公手下吧，省得级别太低，以后查找掌门麻环。” “唔，有道理。” 白面葫芦娃接着打电话给刚才拜访过的三营长……仙子狗尾巴花也做了同样的事情。 这样，查询中所有涉及到的人物都聚集在曹公公的直接领导下。每次查询都做了优化处理，所以整个门派树的层数都会维持在比较低的水平上。路径压缩的代码，看得懂很好，看不懂也没关系，直接抄上用就行了。总之它所实现的功能就是这么个意思。 于是，问题圆满解决。。。。。。。。。 说了这么多，掌握没掌握，还得找个例题做一做呀，上才艺： 题目传送门： 畅通工程http://acm.hdu.edu.cn/showproblem.php?pid=1232 Problem Description 1某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ Input 12345678测试输入包含若干测试用例。每个测试用例的第1行给出两个正整数，分别是城镇数目N ( &lt; 1000 )和道路数目M；随后的M行对应M条道路，每行给出一对正整数，分别是该条道路直接连通的两个城镇的编号。为简单起见，城镇从1到N编号。注意:两个城市之间可以有多条道路相通,也就是说3 31 21 22 1这种输入也是合法的当N为0时，输入结束，该用例不被处理。 Output 1对每个测试用例，在1行里输出最少还需要建设的道路数目。 Sample Input 1234567891011124 21 34 33 31 21 32 35 21 23 5999 00 Sample Output 1234102998 AC代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;cstring&gt;#include &lt;iostream&gt;using namespace std; const int MAXN = 1000 + 5; int pre[MAXN] = &#123;0&#125;; int Find(int x) &#123; int r = x; while (pre[r] != r) r = pre[r]; int i = x, j; while (i != r) &#123; j = pre[i]; pre[i] = r; i = j; &#125; return r;&#125; void Join(int x, int y) &#123; x = Find(x); y = Find(y); if(x != y) pre[x] = y;&#125; int main() &#123; int n, m, x, y; while (cin &gt;&gt; n &gt;&gt; m &amp;&amp; n) &#123; for(int i = 1; i &lt;= n; i++) &#123; pre[i] = i;//初始化节点 &#125; while (m--) &#123;//合并每一条道路 cin &gt;&gt; x &gt;&gt; y; Join(x, y); &#125; int cnt = -1;//注意是初始化-1，因为必然有一个的根节点是自己 for(int i = 1; i &lt;= n; i++) //统计未连接的道路 if(pre[i] == i) cnt++; cout &lt;&lt; cnt &lt;&lt; endl; &#125; return 0;&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://axehco.github.io/HomeWebsite/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法","slug":"算法","permalink":"https://axehco.github.io/HomeWebsite/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"返回倒数第k个节点","slug":"返回倒数第k个节点","date":"2020-11-26T06:10:52.000Z","updated":"2021-09-29T01:32:46.478Z","comments":false,"path":"2020/11/26/返回倒数第k个节点/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"面试题 简单 02.02.","text":"题目描述题目传送门： 返回倒数第 k 个节点https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 示例： 12输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2输出： 4 说明： 给定的 k 保证是有效的。 题解 给出一个长度未知的链表，如何找到链表中倒数第n个结点? 最容易想到的当然是：先从头到尾遍历链表，统计出链表的总长度，从而计算出倒数第n个结点相当于正数第几个结点。 比如链表总长度是10，倒数第3个结点就相当于正数第8个结点。然后从头遍历链表，遍历到第8个结点，就可得到结果。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: cur = head count = 0 while cur is not None: count += 1 cur = cur.next cur = head for i in range(1, count + 1): if i == count - k + 1: return cur.val cur = cur.next 但是这种方法需要经过两次遍历才能得到结果，如果只用一次遍历，是否可以得到结果？ 当然是可以的啦 首先，我们创建两个指针p1和p2，p1指向链表的头结点，p2指向链表的正数第n个结点 。 接下来,我们让指针p1和p2同时循环右移，每次右移一步，直到指针p2移动到链表的末尾。 此时，由于p2指向链表的尾结点，且p1和p2的距离是n-1，因此p1所指的结点就是我们要寻找的链表倒数第n个结点。 显然，这个方法从头到尾只需要对链表做一次遍历，而且仅仅使用了两个指针，算法的空间复杂度是O(1)。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: p1 = head p2 = head # 把p2指针移动到正数第n个结点 for i in range(k - 1): p2 = p2.next # p1和p2一起右移，直到p2指向链表尾结点 while p2.next is not None: p1 = p1.next p2 = p2.next return p1.val","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"有效的字母异位词","slug":"有效的字母异位词","date":"2020-11-26T05:53:07.000Z","updated":"2021-09-29T01:34:55.320Z","comments":false,"path":"2020/11/26/有效的字母异位词/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"Leetcode 简单 242","text":"题目描述题目传送门： 有效的字母异位词https://leetcode-cn.com/problems/valid-anagram/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 12输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true 示例 2: 12输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题解排序比较对两个字符串按照ASCII排序，比较是否相同 AC代码 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return True if sorted(s) == sorted(t) else False 哈希打表题目中字符串只有小写字符，那么就可以定义一个数组(哈希表)，来记录字符串s里字符出现的次数。 再遍历第二个字符串，把字符对应位置的计数减1 最后判断哈希表中元素是否全为0 AC代码 1234567891011class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: hashTable = [0] * 26 for i in s: hashTable[ord(i) - 97] += 1 for i in t: hashTable[ord(i) - 97] -= 1 for i in hashTable: if i != 0: return False return True","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%8E%92%E5%BA%8F/"}]},{"title":"整数反转","slug":"整数反转","date":"2020-11-26T05:51:48.000Z","updated":"2021-09-29T01:35:06.901Z","comments":false,"path":"2020/11/26/整数反转/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"Leetcode 简单 7","text":"题目描述题目传送门： 整数反转https://leetcode-cn.com/problems/reverse-integer/ 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为$[2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。 题解关键点 判断整数的正负 判断反转后的整数是否溢出 AC代码： 1234567891011class Solution: def reverse(self, x: int) -&gt; int: flag = True # 标记正负数 if x &lt; 0: flag = False x = -x # 是负数，就转换为正数 x = str(x)[::-1] # 字符串反转x if not flag: x = -int(x) x = int(x) return x if -1 * pow(2, 31) &lt;= x &lt;= pow(2, 31) - 1 else 0","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2020-11-26T05:49:11.000Z","updated":"2021-09-29T01:35:18.351Z","comments":false,"path":"2020/11/26/最后一个单词的长度/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"Leetcode 简单 58","text":"题目描述题目传送门： 最后一个单词的长度https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 题解易错点 判断字符串是否为空字符串：&quot;&quot;，这种情况单词长度为0 判断字符串是否全部由形如&quot; &quot;的空格组成的，这种情况单词长度也为0 注意形如&quot;a &quot;这种情况的字符串，最后一个空格是不算在单词长度内的 思路先对空字符串和元素全是空格的字符串进行判断，用一个flag作为标记，再将字符串按&#39; &#39;进行切片处理，将切片后的“单词”长度添加到一个临时列表中，反向遍历列表，第一个不为0的元素即为最后一个单词的长度。 AC代码： 1234567891011121314151617class Solution: def lengthOfLastWord(self, s: str) -&gt; int: flag = True # 标记是否为空字符串或元素全是空格的字符串 for i in s: if i != &#x27; &#x27;: flag = False if flag: return 0 lst = s.split(&#x27; &#x27;) ans = [] for i in lst: ans.append(len(i)) # 将切片后的得到的单词长度添加到ans中 ans.reverse() # 末尾寻找“单词” for i in ans: if i == 0: continue return i 分割解法 Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 Python split() 通过指定分隔符对字符串进行切片。 AC代码： 1234class Solution: def lengthOfLastWord(self, s: str) -&gt; int: s = s.strip().split(&#x27; &#x27;) return len(s[-1])","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"独一无二的出现次数","slug":"独一无二的出现次数","date":"2020-11-26T04:24:39.000Z","updated":"2021-09-29T01:32:22.969Z","comments":false,"path":"2020/11/26/独一无二的出现次数/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/","excerpt":"Leetcode 简单 1207","text":"题目描述题目传送门： 独一无二的出现次数https://leetcode-cn.com/problems/unique-number-of-occurrences/ 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr &#x3D; [1,2]输出：false 示例 3： 12输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 题解暴力实现建立一个范围为-1000到1000的数组hash，遍历arr，对arr的元素计数，在遍历一遍hash，找是否存在相同的两个不为0的数即可。 AC代码 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hash = [0] * 2005 for i in arr: hash[i] += 1 for i, j in enumerate(hash): for m, n in enumerate(hash): if m != i and j == n and n != 0: return False return True 用此这种势必会消耗大量的时间和空间了 下面采用另外一种方式 排序+集合先排序数组，然后扫描每一个元素的出现次数并加入set，发现重复次数时返回false，遍历结束后返回true。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 count.sort(reverse = True) set1 = set() for i in count: if i == 0: break else: if i in set1: return False else: set1.add(i) return True 你还记得集合的去重功能吗？还可以这样解： 先计算每个数出现的次数，放在数组hash中，再遍历hash中的数放入集合set中，由于集合的去重性，只需判断hash和set的长度即可。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 cnt = 0 # 记录数组的长度，为0的元素不算在内 set1 = set() for i in count: if i == 0: continue cnt += 1 set1.add(i) if cnt == len(set1): return True else: return False 另一种写法： collections.Counter(arr)是python中的计数函数，不容易记住，所以不推荐使用啦 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: collect = collections.Counter(arr) lst = [] for i in collect.values(): lst.append(i) if len(lst) == len(set(lst)): return True return False","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/HomeWebsite/tags/%E9%9B%86%E5%90%88/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"两个数组的交集","slug":"两个数组的交集","date":"2020-11-26T04:22:20.000Z","updated":"2021-09-29T01:33:33.817Z","comments":false,"path":"2020/11/26/两个数组的交集/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"Leetcode 简单 349","text":"题目描述题目传送门： 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2] 示例 2： 12输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解注意：每个元素唯一，无顺序 暴力实现AC代码 12345678class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: for j in nums2: if j == i: ans.add(j) return list(ans) 时间复杂度：$O(n^2)$ 对暴力的优化 将内层循环修改 AC代码 1234567class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: if i in nums2: ans.add(i) return list(ans) 时间复杂度近似于$O(n)$吧 内置函数python内置函数特性，&amp;运算符取交集 AC带代码 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 哈希表 建立一个空的哈希表和一个空的列表，列表存放答案 哈希表的键存放nums1的数，值就设为1了，当然也可以是其他的数 遍历nums2，如果nums2的值出现在哈希表的键当中，那么把它放到答案的列表中，同时哈希表的值设为None 返回ans即可 AC代码 123456789101112class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic = dict() ans = [] for i in nums1: if dic.get(i) is None: dic[i] = 1 for i in nums2: if dic.get(i) is not None: ans.append(i) dic[i] = None return ans 时间复杂度$O(n)$","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/HomeWebsite/tags/%E9%9B%86%E5%90%88/"}]},{"title":"快乐数","slug":"快乐数","date":"2020-11-26T04:19:46.000Z","updated":"2021-09-29T01:33:18.700Z","comments":false,"path":"2020/11/26/快乐数/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"Leetcode 简单 202","text":"题目描述题目传送门： 快乐数https://leetcode-cn.com/problems/happy-number 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 1234567输入：19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 题解这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，现在看一个不是快乐数的情况。 比如数字11的计算过程： $1^2 + 1^2 = 2$$2^2 = 4$$4^2 = 16$$1^2 + 6^2 = 37$$3^2 + 7^2 = 58$$5^2 + 8^2 = 89$$8^2 + 9^2 = 145$$1^2 + 4^2 + 5^2 = 42$$4^2 + 2^2 = 20$$2^2 + 0^2 = $4 可以发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用 哈希表来记录所有出现过的数字，然后每出现一个新数字，在 哈希表中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回True 哈希迭代AC代码 12345678910111213class Solution: def isHappy(self, n: int) -&gt; bool: visited = set() while n not in visited: visited.add(n) temp = 0 while n != 0: temp += (n % 10) ** 2 n //= 10 if temp == 1: return True n = temp return False 循环迭代经过上面的分析，对于一个非快乐数，其数位平方和最终会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的循环中。 AC代码 12345678class Solution: def isHappy(self, n: int) -&gt; bool: while True: n = sum([int(i)**2 for i in str(n)]) if n == 4: return False if n == 1: return True 下面的不用看：没弄明白 在基于上面的解法后，怕耗时太多，于是我设置了一个k，用k作为每次计算数位平方和的循环计数，当这个数是快乐数时，计算数位平方和的次数一定会有限步内（至于是几步有待考证，这里我k计算到了第6步AC了）计算完收敛到1，但是没有明确的数学证明，我猜想可能是判题时给出的数字太小吧，所以巧过，哈哈哈。 AC代码 1234567891011121314class Solution: def isHappy(self, n: int) -&gt; bool: temp = str(n) k = 0 while True: sum = 0 for i in str(temp): sum += int(i) * int(i) if sum == 1: return True temp = str(sum) k += 1 if k &gt; 5: return False","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"加一","slug":"加一","date":"2020-11-26T04:09:43.000Z","updated":"2021-09-29T01:33:05.049Z","comments":false,"path":"2020/11/26/加一/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/26/%E5%8A%A0%E4%B8%80/","excerpt":"Leetcode 简单 66","text":"题目描述题目传送门： 加一https://leetcode-cn.com/problems/plus-one 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题解投机取巧将digits各个元素转化为整数，整数自加1，转化为字符串列表再将字符串列表转化为整型列表，返回即可 AC代码 12345678910111213class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: digits.reverse() ans = 0 cnt = 1 for i in digits: ans += i * cnt cnt *= 10 result = list(str(ans + 1)) out = [] for i in result: out.append(int(i)) return out 正常解法从后往前依次判断末尾是否为9，如果为9加1后要置为0，继续判断前一位，判断到digits的第一位都是9时，在digits第一位插入1结束；不为9加1后直接返回即可。 AC代码 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: l = len(digits) for i in range(0, l): digits[l - i - 1] = (digits[l - i - 1] + 1) % 10 if digits[l - i - 1] != 0: return digits else: continue digits.insert(0, 1) return digits","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-11-15T07:54:11.000Z","updated":"2021-09-29T01:33:51.919Z","comments":false,"path":"2020/11/15/两数之和/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"Leetcode 简单 1","text":"问题描述题目传送门： 两数之和https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 实例： 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解暴力求解 遍历数组，判断target - num是否也在list中，如果满足，还需判断target - num的下标不能是num的下标，但此方法效率较长。 AC代码： 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: nums = list(nums) for index, num in enumerate(nums): if target - num in nums and nums.index(target - num) != index: return [index, nums.index(target - num)] 打表实现 哈希表：简单来说就是存有键值对[key, value]的一种数据结构，其查找速度是最快的。因此为了提高查找的效率，可以通过字典来模拟哈希查询，只用一次循环即可解决。 AC代码： 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = dict() for index, num in enumerate(nums): temp = dic.get(target - num) if temp is not None: return [temp, index] dic[num] = index","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"丢失的数字","slug":"丢失的数字","date":"2020-11-14T08:55:45.000Z","updated":"2021-09-29T01:30:52.591Z","comments":false,"path":"2020/11/14/丢失的数字/","link":"","permalink":"https://axehco.github.io/HomeWebsite/2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"Leetcode 简单 268","text":"问题描述题目传送门 丢失的数字https://leetcode-cn.com/problems/missing-number/ 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 123输入：nums &#x3D; [3,0,1]输出：2解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums &#x3D; [0,1]输出：2解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]输出：8解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums &#x3D; [0]输出：1解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 题解数学解法先求出0到n这n+1个数的和再求出nums中所有数的和两者相减，得到的即为丢失的数字 AC代码： 1234567class Solution: def missingNumber(self, nums: List[int]) -&gt; int: sum = int((1 + len(nums)) * len(nums) / 2) sum1 = 0 for i in nums: sum1 += i return sum - sum1 哈希表实现哈希表实现产生n+1个bool型的数遍历一遍，改变其值再输出即可 AC代码： 12345678class Solution: def missingNumber(self, nums: List[int]) -&gt; int: Hash = [True for i in range(len(nums) + 1)] for i in nums: Hash[i] = False for i, j in enumerate(Hash): if j: return i","categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]}],"categories":[{"name":"LeetCode简单","slug":"LeetCode简单","permalink":"https://axehco.github.io/HomeWebsite/categories/LeetCode%E7%AE%80%E5%8D%95/"},{"name":"数据结构","slug":"数据结构","permalink":"https://axehco.github.io/HomeWebsite/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/HomeWebsite/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/HomeWebsite/tags/Python/"},{"name":"字符串匹配","slug":"字符串匹配","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"},{"name":"KMP","slug":"KMP","permalink":"https://axehco.github.io/HomeWebsite/tags/KMP/"},{"name":"二进制","slug":"二进制","permalink":"https://axehco.github.io/HomeWebsite/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"循环","slug":"循环","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%BE%AA%E7%8E%AF/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E7%BB%84/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%9A%B4%E5%8A%9B/"},{"name":"计数排序","slug":"计数排序","permalink":"https://axehco.github.io/HomeWebsite/tags/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/"},{"name":"二分查找","slug":"二分查找","permalink":"https://axehco.github.io/HomeWebsite/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"name":"并查集","slug":"并查集","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"},{"name":"算法","slug":"算法","permalink":"https://axehco.github.io/HomeWebsite/tags/%E7%AE%97%E6%B3%95/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/HomeWebsite/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%8E%92%E5%BA%8F/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/HomeWebsite/tags/%E6%95%B0%E5%AD%A6/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/HomeWebsite/tags/%E9%9B%86%E5%90%88/"}]}