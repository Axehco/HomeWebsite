{"meta":{"title":"AXEHCO'S BLOG","subtitle":"","description":"","author":"Axehco","url":"https://Axehco.github.io","root":"/"},"pages":[{"title":"","date":"2020-11-14T06:02:47.088Z","updated":"2020-11-14T06:02:47.088Z","comments":true,"path":"404.html","permalink":"https://axehco.github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"技术大佬","date":"2020-11-27T07:15:49.958Z","updated":"2020-11-27T07:15:49.958Z","comments":false,"path":"friends/index.html","permalink":"https://axehco.github.io/friends/index.html","excerpt":"友链功能暂未开发，去看看其他吧~","text":"友链功能暂未开发，去看看其他吧~"},{"title":"所有标签","date":"2020-11-14T05:44:31.206Z","updated":"2020-11-14T05:44:31.206Z","comments":true,"path":"tags/index.html","permalink":"https://axehco.github.io/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-27T15:30:29.155Z","updated":"2020-11-27T15:29:25.981Z","comments":true,"path":"index.html","permalink":"https://axehco.github.io/index.html","excerpt":"","text":"Sponsor-Page Sponsor PayPal Bitcoin AliPay WeChat"},{"title":"所有分类","date":"2020-11-14T15:39:25.493Z","updated":"2020-11-14T15:39:25.493Z","comments":true,"path":"categories/index.html","permalink":"https://axehco.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-14T05:45:32.376Z","updated":"2020-11-14T05:45:32.376Z","comments":true,"path":"mylist/index.html","permalink":"https://axehco.github.io/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"返回倒数第k个节点","slug":"返回倒数第k个节点","date":"2020-11-26T06:10:52.000Z","updated":"2020-11-26T06:13:49.458Z","comments":false,"path":"2020/11/26/返回倒数第k个节点/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E8%BF%94%E5%9B%9E%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/","excerpt":"如何找到链表中倒数第n个节点呢？","text":"题目描述题目传送门： 返回倒数第 k 个节点https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/ 实现一种算法，找出单向链表中倒数第 k 个节点。返回该节点的值。 示例： 12输入： 1-&gt;2-&gt;3-&gt;4-&gt;5 和 k &#x3D; 2输出： 4 说明： 给定的 k 保证是有效的。 题解 给出一个长度未知的链表，如何找到链表中倒数第n个结点? 最容易想到的当然是：先从头到尾遍历链表，统计出链表的总长度，从而计算出倒数第n个结点相当于正数第几个结点。 比如链表总长度是10，倒数第3个结点就相当于正数第8个结点。然后从头遍历链表，遍历到第8个结点，就可得到结果。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: cur = head count = 0 while cur is not None: count += 1 cur = cur.next cur = head for i in range(1, count + 1): if i == count - k + 1: return cur.val cur = cur.next 但是这种方法需要经过两次遍历才能得到结果，如果只用一次遍历，是否可以得到结果？ 当然是可以的啦 首先，我们创建两个指针p1和p2，p1指向链表的头结点，p2指向链表的正数第n个结点 。 接下来,我们让指针p1和p2同时循环右移，每次右移一步，直到指针p2移动到链表的末尾。 此时，由于p2指向链表的尾结点，且p1和p2的距离是n-1，因此p1所指的结点就是我们要寻找的链表倒数第n个结点。 显然，这个方法从头到尾只需要对链表做一次遍历，而且仅仅使用了两个指针，算法的空间复杂度是O(1)。 AC代码 123456789101112131415161718# Definition for singly-linked list.# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: def kthToLast(self, head: ListNode, k: int) -&gt; int: p1 = head p2 = head # 把p2指针移动到正数第n个结点 for i in range(k - 1): p2 = p2.next # p1和p2一起右移，直到p2指向链表尾结点 while p2.next is not None: p1 = p1.next p2 = p2.next return p1.val","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"}]},{"title":"有效的字母异位词","slug":"有效的字母异位词","date":"2020-11-26T05:53:07.000Z","updated":"2020-11-26T07:49:42.698Z","comments":false,"path":"2020/11/26/有效的字母异位词/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D/","excerpt":"哈希表的应用","text":"题目描述题目传送门： 有效的字母异位词https://leetcode-cn.com/problems/valid-anagram/ 给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 示例 1: 12输入: s &#x3D; &quot;anagram&quot;, t &#x3D; &quot;nagaram&quot;输出: true 示例 2: 12输入: s &#x3D; &quot;rat&quot;, t &#x3D; &quot;car&quot;输出: false 说明: 你可以假设字符串只包含小写字母。 进阶: 如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ 题解排序比较对两个字符串按照ASCII排序，比较是否相同 AC代码 123class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: return True if sorted(s) == sorted(t) else False 哈希打表题目中字符串只有小写字符，那么就可以定义一个数组(哈希表)，来记录字符串s里字符出现的次数。 再遍历第二个字符串，把字符对应位置的计数减1 最后判断哈希表中元素是否全为0 AC代码 1234567891011class Solution: def isAnagram(self, s: str, t: str) -&gt; bool: hashTable = [0] * 26 for i in s: hashTable[ord(i) - 97] += 1 for i in t: hashTable[ord(i) - 97] -= 1 for i in hashTable: if i != 0: return False return True","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"整数反转","slug":"整数反转","date":"2020-11-26T05:51:48.000Z","updated":"2020-11-27T13:06:45.399Z","comments":false,"path":"2020/11/26/整数反转/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%95%B4%E6%95%B0%E5%8F%8D%E8%BD%AC/","excerpt":"python中32位的有符号整数","text":"题目描述题目传送门： 整数反转https://leetcode-cn.com/problems/reverse-integer/ 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 示例 1: 12输入: 123输出: 321 示例 2: 12输入: -123输出: -321 示例 3: 12输入: 120输出: 21 注意: 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为$[2^{31}, 2^{31}-1]$。请根据这个假设，如果反转后整数溢出那么就返回 0。 题解关键点 判断整数的正负 判断反转后的整数是否溢出 AC代码： 1234567891011class Solution: def reverse(self, x: int) -&gt; int: flag = True # 标记正负数 if x &lt; 0: flag = False x = -x # 是负数，就转换为正数 x = str(x)[::-1] # 字符串反转x if not flag: x = -int(x) x = int(x) return x if -1 * pow(2, 31) &lt;= x &lt;= pow(2, 31) - 1 else 0","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"}]},{"title":"最后一个单词的长度","slug":"最后一个单词的长度","date":"2020-11-26T05:49:11.000Z","updated":"2020-11-26T07:49:18.567Z","comments":false,"path":"2020/11/26/最后一个单词的长度/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/","excerpt":"python中split()和strip()方法","text":"题目描述题目传送门： 最后一个单词的长度https://leetcode-cn.com/problems/length-of-last-word/ 给定一个仅包含大小写字母和空格 &#39; &#39; 的字符串 s，返回其最后一个单词的长度。如果字符串从左向右滚动显示，那么最后一个单词就是最后出现的单词。 如果不存在最后一个单词，请返回 0 。 说明：一个单词是指仅由字母组成、不包含任何空格字符的最大子字符串。 示例: 12输入: &quot;Hello World&quot;输出: 5 题解易错点 判断字符串是否为空字符串：&quot;&quot;，这种情况单词长度为0 判断字符串是否全部由形如&quot; &quot;的空格组成的，这种情况单词长度也为0 注意形如&quot;a &quot;这种情况的字符串，最后一个空格是不算在单词长度内的 思路先对空字符串和元素全是空格的字符串进行判断，用一个flag作为标记，再将字符串按&#39; &#39;进行切片处理，将切片后的“单词”长度添加到一个临时列表中，反向遍历列表，第一个不为0的元素即为最后一个单词的长度。 AC代码： 1234567891011121314151617class Solution: def lengthOfLastWord(self, s: str) -&gt; int: flag = True # 标记是否为空字符串或元素全是空格的字符串 for i in s: if i != &#x27; &#x27;: flag = False if flag: return 0 lst = s.split(&#x27; &#x27;) ans = [] for i in lst: ans.append(len(i)) # 将切片后的得到的单词长度添加到ans中 ans.reverse() # 末尾寻找“单词” for i in ans: if i == 0: continue return i 分割解法 Python strip() 方法用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 注意：该方法只能删除开头或是结尾的字符，不能删除中间部分的字符。 Python split() 通过指定分隔符对字符串进行切片。 AC代码： 1234class Solution: def lengthOfLastWord(self, s: str) -&gt; int: s = s.strip().split(&#x27; &#x27;) return len(s[-1])","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"独一无二的出现次数","slug":"独一无二的出现次数","date":"2020-11-26T04:24:39.000Z","updated":"2020-11-26T04:26:35.338Z","comments":false,"path":"2020/11/26/独一无二的出现次数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E7%8B%AC%E4%B8%80%E6%97%A0%E4%BA%8C%E7%9A%84%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0/","excerpt":"集合的去重你还能想起吗？","text":"题目描述题目传送门： 独一无二的出现次数https://leetcode-cn.com/problems/unique-number-of-occurrences/ 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr &#x3D; [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr &#x3D; [1,2]输出：false 示例 3： 12输入：arr &#x3D; [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 题解暴力实现建立一个范围为-1000到1000的数组hash，遍历arr，对arr的元素计数，在遍历一遍hash，找是否存在相同的两个不为0的数即可。 AC代码 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: hash = [0] * 2005 for i in arr: hash[i] += 1 for i, j in enumerate(hash): for m, n in enumerate(hash): if m != i and j == n and n != 0: return False return True 用此这种势必会消耗大量的时间和空间了 下面采用另外一种方式 排序+集合先排序数组，然后扫描每一个元素的出现次数并加入set，发现重复次数时返回false，遍历结束后返回true。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 count.sort(reverse = True) set1 = set() for i in count: if i == 0: break else: if i in set1: return False else: set1.add(i) return True 你还记得集合的去重功能吗？还可以这样解： 先计算每个数出现的次数，放在数组hash中，再遍历hash中的数放入集合set中，由于集合的去重性，只需判断hash和set的长度即可。 AC代码 12345678910111213141516class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: count = [0] * 2005 for i in arr: count[i] += 1 cnt = 0 # 记录数组的长度，为0的元素不算在内 set1 = set() for i in count: if i == 0: continue cnt += 1 set1.add(i) if cnt == len(set1): return True else: return False 另一种写法： collections.Counter(arr)是python中的计数函数，不容易记住，所以不推荐使用啦 12345678910class Solution: def uniqueOccurrences(self, arr: List[int]) -&gt; bool: collect = collections.Counter(arr) lst = [] for i in collect.values(): lst.append(i) if len(lst) == len(set(lst)): return True return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]},{"title":"两个数组的交集","slug":"两个数组的交集","date":"2020-11-26T04:22:20.000Z","updated":"2020-11-26T04:23:57.722Z","comments":false,"path":"2020/11/26/两个数组的交集/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86/","excerpt":"范围太大还能用哈希表吗？","text":"题目描述题目传送门： 两个数组的交集https://leetcode-cn.com/problems/intersection-of-two-arrays 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 &#x3D; [1,2,2,1], nums2 &#x3D; [2,2]输出：[2] 示例 2： 12输入：nums1 &#x3D; [4,9,5], nums2 &#x3D; [9,4,9,8,4]输出：[9,4] 说明： 输出结果中的每个元素一定是唯一的。 我们可以不考虑输出结果的顺序。 题解注意：每个元素唯一，无顺序 暴力实现AC代码 12345678class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: for j in nums2: if j == i: ans.add(j) return list(ans) 时间复杂度：$O(n^2)$ 对暴力的优化 将内层循环修改 AC代码 1234567class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: ans = set() for i in nums1: if i in nums2: ans.add(i) return list(ans) 时间复杂度近似于$O(n)$吧 内置函数python内置函数特性，&amp;运算符取交集 AC带代码 123class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: return list(set(nums1) &amp; set(nums2)) 哈希表 建立一个空的哈希表和一个空的列表，列表存放答案 哈希表的键存放nums1的数，值就设为1了，当然也可以是其他的数 遍历nums2，如果nums2的值出现在哈希表的键当中，那么把它放到答案的列表中，同时哈希表的值设为None 返回ans即可 AC代码 123456789101112class Solution: def intersection(self, nums1: List[int], nums2: List[int]) -&gt; List[int]: dic = dict() ans = [] for i in nums1: if dic.get(i) is None: dic[i] = 1 for i in nums2: if dic.get(i) is not None: ans.append(i) dic[i] = None return ans 时间复杂度$O(n)$","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"}]},{"title":"快乐数","slug":"快乐数","date":"2020-11-26T04:19:46.000Z","updated":"2020-11-26T04:21:49.459Z","comments":false,"path":"2020/11/26/快乐数/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%BF%AB%E4%B9%90%E6%95%B0/","excerpt":"哈希迭代，真的快乐吗？","text":"题目描述题目传送门： 快乐数https://leetcode-cn.com/problems/happy-number 编写一个算法来判断一个数 n 是不是快乐数。 「快乐数」定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。 如果 n 是快乐数就返回 True ；不是，则返回 False 。 示例： 1234567输入：19输出：true解释：12 + 92 &#x3D; 8282 + 22 &#x3D; 6862 + 82 &#x3D; 10012 + 02 + 02 &#x3D; 1 题解这道题定义了一种快乐数，就是说对于某一个正整数，如果对其各个位上的数字分别平方，然后再加起来得到一个新的数字，再进行同样的操作，如果最终结果变成了1，则说明是快乐数，如果一直循环但不是1的话，就不是快乐数，那么现在任意给我们一个正整数，让我们判断这个数是不是快乐数，题目中给的例子19是快乐数，现在看一个不是快乐数的情况。 比如数字11的计算过程： $1^2 + 1^2 = 2$$2^2 = 4$$4^2 = 16$$1^2 + 6^2 = 37$$3^2 + 7^2 = 58$$5^2 + 8^2 = 89$$8^2 + 9^2 = 145$$1^2 + 4^2 + 5^2 = 42$$4^2 + 2^2 = 20$$2^2 + 0^2 = $4 可以发现在算到最后时数字4又出现了，那么之后的数字又都会重复之前的顺序，这个循环中不包含1，那么数字11不是一个快乐数，发现了规律后就要考虑怎么用代码来实现，我们可以用 哈希表来记录所有出现过的数字，然后每出现一个新数字，在 哈希表中查找看是否存在，若不存在则加入表中，若存在则跳出循环，并且判断此数是否为1，若为1返回True 哈希迭代AC代码 12345678910111213class Solution: def isHappy(self, n: int) -&gt; bool: visited = set() while n not in visited: visited.add(n) temp = 0 while n != 0: temp += (n % 10) ** 2 n //= 10 if temp == 1: return True n = temp return False 循环迭代经过上面的分析，对于一个非快乐数，其数位平方和最终会进入4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4的循环中。 AC代码 12345678class Solution: def isHappy(self, n: int) -&gt; bool: while True: n = sum([int(i)**2 for i in str(n)]) if n == 4: return False if n == 1: return True 下面的不用看：没弄明白 在基于上面的解法后，怕耗时太多，于是我设置了一个k，用k作为每次计算数位平方和的循环计数，当这个数是快乐数时，计算数位平方和的次数一定会有限步内（至于是几步有待考证，这里我k计算到了第6步AC了）计算完收敛到1，但是没有明确的数学证明，我猜想可能是判题时给出的数字太小吧，所以巧过，哈哈哈。 AC代码 1234567891011121314class Solution: def isHappy(self, n: int) -&gt; bool: temp = str(n) k = 0 while True: sum = 0 for i in str(temp): sum += int(i) * int(i) if sum == 1: return True temp = str(sum) k += 1 if k &gt; 5: return False","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]},{"title":"加一","slug":"加一","date":"2020-11-26T04:09:43.000Z","updated":"2020-11-26T04:19:08.445Z","comments":false,"path":"2020/11/26/加一/","link":"","permalink":"https://axehco.github.io/2020/11/26/%E5%8A%A0%E4%B8%80/","excerpt":"简单的数组操作题","text":"题目描述题目传送门： 加一https://leetcode-cn.com/problems/plus-one 给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。 你可以假设除了整数 0 之外，这个整数不会以零开头。 示例 1: 123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。 示例 2: 123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。 题解投机取巧将digits各个元素转化为整数，整数自加1，转化为字符串列表再将字符串列表转化为整型列表，返回即可 AC代码 12345678910111213class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: digits.reverse() ans = 0 cnt = 1 for i in digits: ans += i * cnt cnt *= 10 result = list(str(ans + 1)) out = [] for i in result: out.append(int(i)) return out 正常解法从后往前依次判断末尾是否为9，如果为9加1后要置为0，继续判断前一位，判断到digits的第一位都是9时，在digits第一位插入1结束；不为9加1后直接返回即可。 AC代码 1234567891011class Solution: def plusOne(self, digits: List[int]) -&gt; List[int]: l = len(digits) for i in range(0, l): digits[l - i - 1] = (digits[l - i - 1] + 1) % 10 if digits[l - i - 1] != 0: return digits else: continue digits.insert(0, 1) return digits","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"两数之和","slug":"两数之和","date":"2020-11-15T07:54:11.000Z","updated":"2020-11-18T04:12:32.219Z","comments":false,"path":"2020/11/15/两数之和/","link":"","permalink":"https://axehco.github.io/2020/11/15/%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/","excerpt":"哈希表的应用","text":"问题描述题目传送门： 两数之和https://leetcode-cn.com/problems/two-sum/ 给定一个整数数组nums和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 实例： 1234给定 nums &#x3D; [2, 7, 11, 15], target &#x3D; 9因为 nums[0] + nums[1] &#x3D; 2 + 7 &#x3D; 9所以返回 [0, 1] 题解暴力求解 遍历数组，判断target - num是否也在list中，如果满足，还需判断target - num的下标不能是num的下标，但此方法效率较长。 AC代码： 123456class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: nums = list(nums) for index, num in enumerate(nums): if target - num in nums and nums.index(target - num) != index: return [index, nums.index(target - num)] 打表实现 哈希表：简单来说就是存有键值对[key, value]的一种数据结构，其查找速度是最快的。因此为了提高查找的效率，可以通过字典来模拟哈希查询，只用一次循环即可解决。 AC代码： 12345678class Solution: def twoSum(self, nums: List[int], target: int) -&gt; List[int]: dic = dict() for index, num in enumerate(nums): temp = dic.get(target - num) if temp is not None: return [temp, index] dic[num] = index","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"}]},{"title":"丢失的数字","slug":"丢失的数字","date":"2020-11-14T08:55:45.000Z","updated":"2020-11-18T05:09:02.119Z","comments":false,"path":"2020/11/14/丢失的数字/","link":"","permalink":"https://axehco.github.io/2020/11/14/%E4%B8%A2%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/","excerpt":"巧用数学思维","text":"问题描述题目传送门 丢失的数字https://leetcode-cn.com/problems/missing-number/ 给定一个包含 [0, n] 中 n 个数的数组 nums ，找出 [0, n] 这个范围内没有出现在数组中的那个数。 进阶： 你能否实现线性时间复杂度、仅使用额外常数空间的算法解决此问题? 示例 1： 123输入：nums &#x3D; [3,0,1]输出：2解释：n &#x3D; 3，因为有 3 个数字，所以所有的数字都在范围 [0,3] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 2： 123输入：nums &#x3D; [0,1]输出：2解释：n &#x3D; 2，因为有 2 个数字，所以所有的数字都在范围 [0,2] 内。2 是丢失的数字，因为它没有出现在 nums 中。 示例 3： 123输入：nums &#x3D; [9,6,4,2,3,5,7,0,1]输出：8解释：n &#x3D; 9，因为有 9 个数字，所以所有的数字都在范围 [0,9] 内。8 是丢失的数字，因为它没有出现在 nums 中。 示例 4： 123输入：nums &#x3D; [0]输出：1解释：n &#x3D; 1，因为有 1 个数字，所以所有的数字都在范围 [0,1] 内。1 是丢失的数字，因为它没有出现在 nums 中。 提示： n == nums.length 1 &lt;= n &lt;= 104 0 &lt;= nums[i] &lt;= n nums 中的所有数字都 独一无二 题解数学解法先求出0到n这n+1个数的和再求出nums中所有数的和两者相减，得到的即为丢失的数字 AC代码： 1234567class Solution: def missingNumber(self, nums: List[int]) -&gt; int: sum = int((1 + len(nums)) * len(nums) / 2) sum1 = 0 for i in nums: sum1 += i return sum - sum1 哈希表实现哈希表实现产生n+1个bool型的数遍历一遍，改变其值再输出即可 AC代码： 12345678class Solution: def missingNumber(self, nums: List[int]) -&gt; int: Hash = [True for i in range(len(nums) + 1)] for i in nums: Hash[i] = False for i, j in enumerate(Hash): if j: return i","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"}]}],"categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/categories/LeetCode/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://axehco.github.io/tags/LeetCode/"},{"name":"Python","slug":"Python","permalink":"https://axehco.github.io/tags/Python/"},{"name":"链表","slug":"链表","permalink":"https://axehco.github.io/tags/%E9%93%BE%E8%A1%A8/"},{"name":"双指针","slug":"双指针","permalink":"https://axehco.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"},{"name":"哈希表","slug":"哈希表","permalink":"https://axehco.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"},{"name":"排序","slug":"排序","permalink":"https://axehco.github.io/tags/%E6%8E%92%E5%BA%8F/"},{"name":"字符串","slug":"字符串","permalink":"https://axehco.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数学","slug":"数学","permalink":"https://axehco.github.io/tags/%E6%95%B0%E5%AD%A6/"},{"name":"集合","slug":"集合","permalink":"https://axehco.github.io/tags/%E9%9B%86%E5%90%88/"},{"name":"数组","slug":"数组","permalink":"https://axehco.github.io/tags/%E6%95%B0%E7%BB%84/"},{"name":"暴力","slug":"暴力","permalink":"https://axehco.github.io/tags/%E6%9A%B4%E5%8A%9B/"}]}